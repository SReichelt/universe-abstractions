\documentclass[a4paper]{article}

\usepackage[margin=2.5cm]{geometry}
\usepackage[parfill]{parskip}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}

\usepackage{amsmath,amssymb,amsfonts,amsthm}
\usepackage{longtable}

\title{Universe Abstractions\footnote{Still searching for a better title.}}
\author{Sebastian Reichelt}

\setlength{\skip\footins}{0.5cm}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}[definition]{Theorem}
\newtheorem{proposition}[definition]{Proposition}
\newtheorem{lemma}[definition]{Lemma}
\newtheorem{corollary}[definition]{Corollary}
\newtheorem{conjecture}[definition]{Conjecture}
\theoremstyle{remark}
\newtheorem*{remark}{Remark}
\newtheorem*{remarks}{Remarks}
\newtheorem*{example}{Example}

\newcommand{\defn}{\emph}

\renewcommand{\phi}{\varphi}
\renewcommand{\equiv}{\simeq}
\renewcommand{\emptyset}{\varnothing}

\newcommand{\A}{\mathcal{A}}
\newcommand{\B}{\mathcal{B}}
\newcommand{\C}{\mathcal{C}}
\newcommand{\D}{\mathcal{D}}
\newcommand{\U}{\mathcal{U}}
\newcommand{\V}{\mathcal{V}}
\newcommand{\W}{\mathcal{W}}

\newcommand{\nm}{\mathsf}

\newcommand{\universe}{\nm}
\newcommand{\Unit}{\universe{Unit}}
\newcommand{\Bool}{\universe{Bool}}
\newcommand{\Prop}{\universe{Prop}}
\newcommand{\Set}{\universe{Set}}

\newcommand{\id}{\nm{id}}
\newcommand{\apply}{\nm{apply}}
\newcommand{\congrArg}{\nm{wd}}
\newcommand{\fndef}[1]{\nm{def}_{#1}}

\newcommand{\combinator}{\nm}
\newcommand{\idFun}{\combinator{I}}
\newcommand{\revAppFun}{\combinator{T}}
\newcommand{\constFun}{\combinator{K}}
\newcommand{\compFun}{\combinator{B'}}
\newcommand{\revCompFun}{\combinator{B}}
\newcommand{\swapFun}{\combinator{C}}
\newcommand{\dupFun}{\combinator{W}}
\newcommand{\substFun}{\combinator{S'}}
\newcommand{\revSubstFun}{\combinator{S}}

\newcommand{\Lean}{\texttt}

\begin{document}

\maketitle

\section{Introduction}

In this document, we describe a mathematical framework to automate proofs that follow from structural
properties. Such automation can be implemented in theorem provers, and in fact this document is
largely intended as documentation for the accompanying formalization in Lean 4 \cite{lean4}.
At the same time, the algorithms are simple enough to be carried out by hand, and quite often the
existence of an algorithm can be used to prove a result without actually executing the algorithm, so
our results can be useful for informal mathematics as well.

The framework is built around the realization that categories and functors form a simply-typed lambda
calculus \cite{simply-typed-lambda-calculus} when objects are regarded up to isomorphism, because
functors corresponding to the $\nm{S}$ and $\nm{K}$ combinators exist (theorem
\ref{thm:funop}).\footnote{This is different from the interpretation of simply-typed lambda calculus
as the internal logic of a Cartesian closed category, mainly due to the different interpretation of
equality. In particular, our result applies to \emph{any} category, or more precisely to the
collection of categories.}
So it is possible to prove that a function between categories is functorial just by observing that it
is a term in simply-typed lambda calculus, or, as we state it, its definition is built from functor
applications (proposition \ref{prp:functoriality}). We then generalize this result by including
further categorical structures, which corresponds to enriching the lambda calculus with more types.

A particularly useful consequence arises from certain extensionality conditions that hold for
categories: if for two functors $F,G : \C \to \D$ we have an isomorphism between $F(a)$ and $G(a)$
for a sufficiently `generic' $a$ (which we make precise), then $F$ and $G$ are naturally isomorphic
(theorem \ref{thm:extensionality}).

The main goal is to automate proofs of isomorphism invariance in a similar way, but this is work in
progress.

The framework is influenced by ideas from Homotopy Type Theory \cite{hottbook}, but it is built on
conventional mathematical foundations: in this document, we work in Zermelo-Fraenkel (ZF) set
theory with universes, whereas the Lean formalization is directly based on the Calculus of Inductive
Constructions implemented in Lean, without assuming any additional axioms. When we use
type-theoretic notation and vocabulary, it always refers to a specific definition that we give in
this document.

\section{Universes}
\label{sec:universes}

Although we specifically work in Zermelo-Fraenkel (ZF) set theory with (a finite number of)
Grothendieck universes, we will ignore all issues related to the sizes of collections.
Explicit universe constraints are given in the Lean formalization. Since the logic
implemented in Lean has been proved to be equiconsistent with ZF plus choice and a finite
number of inaccessible cardinals \cite{lean-type-theory}, it is safe to assume that analogous
constraints are sufficient in the latter.

Therefore, we reserve the word `universe' for our own use except where specified otherwise:

\begin{definition}
  We define a \defn{universe} to be a pair $(I, (S_A)_{A \in I})$ of
  \begin{itemize}
    \item an index set $I,$ the members of which we call \defn{types}, and
    \item a family $(S_A)_{A \in I}$ of sets indexed by a type. We call the members of $S_A$ the
    \defn{instances} of $A.$
  \end{itemize}
\end{definition}

Given a universe $\U = (I, (S_A)_{A \in I}),$ we write
\begin{itemize}
  \item ``$A \in \U$'' for ``$A \in I$'' and
  \item ``$a :_\U A$'' or usually just ``$a : A$'' for ``$a \in S_A.$''
\end{itemize}

Despite the use of type-theoretic notation and vocabulary, we would like to stress that we are not
defining a type theory; our definitions are just \emph{informed} by type theory.\footnote{One
could also say that we are directly working with \emph{models} of typed lambda calculi. In any case,
we avoid defining the syntax of lambda calculus.}
The words `universe', `type', and `instance' do not carry any meaning beyond what is defined above.

It is important to distinguish between ``$a : A$'' and ``$a \in A$'' because $A$ may in fact be a
set that is different from $S_A.$\footnote{$A$ is always a set in ZF in theory, but in our case it
may also be a set in practice.} This difference can be regarded as an indirection, similarly to
Tarski-style universes in type theory \cite{tarski}.

Since the definition of a universe does not contain any axioms about types and instances, there
are a lot of examples of such universes. Fix a Grothendieck universe $U.$

\begin{itemize}
  \item For every collection $\C \subseteq U$ of sets in $U,$ $\Set_\C := (\C, (S)_{S \in \C})$ is a
  universe for which ``$:$'' and ``$\in$'' coincide.
  If $\C = U,$ we just write ``$\Set$'' (again, ignoring all size issues).
  \item For every collection $\C$ of algebraic structures of the form $(S, t_S)$ with $S \in U,$
  $(\C, (S)_{(S, t_S) \in \C})$ is a universe.\\
  As an example, let $\C$ be the set of all $U$-small groups. Then each type $A$ is a group, and
  each instance $a : A$ is member of the carrier set of $A$ (i.e.\ informally a member of $A$).\\
  The universe of categories will be of particular importance, where types are categories and instances
  are objects in those categories.\\
  Another example is that $\C$ is a collection of universes. Then each type is itself a universe, and
  its instances are the types in that universe.
  \item The previous example generalizes to structures that are built not on sets but on types in a
  universe $\U = (I, (S_A)_{A \in I}).$ Let $\C$ be a collection of structures of the form $(A,t_A)$ with
  $A \in \U$. Then $(\C, (S_A)_{(A, t_A) \in \C})$ is also a universe.
  \item For a universe $\U = (I, (S_A)_{A \in I}),$ any subset $J \subseteq I$ gives rise to a
  \defn{subuniverse} $(J, (S_A)_{A \in J}).$
  \item For any two universes $\U = (I, (S_A)_{A \in I})$ and $\V = (J, (T_B)_{B \in J}),$ we have a
  product universe $\U \times \V := (I{\times}J,\,(S_A{\times}T_B)_{(A,B) \in I{\times}J}),$ as well as a
  sum universe $\U \uplus \V := (I \uplus J,\,(R_A)_{A \in I \uplus J})$ with $R_A := S_A$ for $A \in I$
  and $R_B := T_B$ for $B \in J$ (where $I \times J$ denotes the Cartesian product and $I \uplus J$
  denotes the disjoint union of $I$ and $J$).
\end{itemize}

Furthermore, we define two specific universes of interest:
\begin{itemize}
  \item $\Bool := \Set_{\{0, 1\}},$ where $0$ and $1$ are to be understood as von Neumann ordinals
  \cite{von-neumann-ordinals}, so that $0$ is an empty type and $1$ is a type with a single
  instance $\emptyset : 1.$\footnote{In the Lean formalization of this theory, we have two different universes
  corresponding to the Lean types \Lean{Bool} and \Lean{Prop}. Both of them map to $\Bool$ in this document.}
  \item $\Unit := \Set_{\{1\}}.$
\end{itemize}

Universes are too generic to prove general statements about all universes, so in the following sections
we will define additional structure that universes may or may not have, and prove statements depending
on such additional structure.

\section{Meta-relations}
\label{sec:meta-relations}

\begin{definition}
  For a set $S$ and a universe $\V = (J, (T_B)_{B \in J}),$ we define a \defn{$\V$-valued meta-relation}
  on $S$ to be a function $(\prec) : S \times S \to J.$
\end{definition}

(We reserve the word ``relation'' for section \ref{sec:relations}, where we replace the set $S$ with a type
in a universe.)

We will write $(\prec)$ in infix form, but note that $(\prec)$ is a function and for $a,b \in S,$ the
expression ``$a \prec b$'' is not a formula but a type in $\V.$
We say that $(\prec)$ is
\begin{itemize}
  \item \defn{reflexive} if for every $a \in S$ we have an instance $\id_a : a \prec a,$
  \item \defn{symmetric} if for every $a,b \in S$ and $f : a \prec b$ we have an instance
  $f^{-1} : b \prec a,$ and
  \item \defn{transitive} if for every $a,b,c \in S,$ $f : a \prec b,$ and $g : b \prec c$ we have an
  instance $g \circ f : a \prec c.$
\end{itemize}

Let us first justify the terminology, then the notation. So first consider a (set-theoretic) relation
$(\sim)$ on $S.$ Then for $\V := \Bool$ and
\[(a \prec b) := \begin{cases}
  \, 1 & \text{if } a \sim b,\\
  \, 0 & \text{otherwise}
\end{cases}\]
for $a,b \in S,$ $(\prec)$ is reflexive/symmetric/transitive whenever $(\sim)$ is.

The notation we use for the three specific instances can be understood category-theoretically:
Let $S$ be the set of objects in a category, and let $(a \to b)$ denote the set of morphisms
from $a \in S$ to $b \in S.$ Then the morphism arrow $(\to)$ is in fact a $\Set$-valued
meta-relation on $S,$ and all notations coincide:
\begin{itemize}
  \item A morphism $f : a \to b$ is indeed an instance of the type $(a \to b) \in \Set.$
  \item For each $a \in S,$ we have $\id_a : a \to a.$
  \item For an isomorphism $f : a \to b,$ we have $f^{-1} : b \to a.$
  \item For morphisms $f : a \to b$ and $g : b \to c,$ we have $g \circ f : a \to c.$
\end{itemize}

So morphisms in a category form a reflexive and transitive $\Set$-valued meta-relation.
Moreover, isomorphisms form a reflexive, symmetric, and transitive $\Set$-valued meta-relation.

Note, however, that in general we do not assume that $(\circ)$ is associative, that $\id_a$ is
an identity with respect to $(\circ),$ or that $f^{-1}$ is an inverse of $f.$ We will add such
assumptions later when needed, but in a more general form that avoids equality. For now, we
arbitrarily define the symbol ``$\circ$'' to be right-associative.

(See also \cite{hottbook}, section 2.1.)

\subsection{Instance equivalences}

\begin{definition}
  From now on, we will assume every universe $\U = (I, (S_A)_{A \in I})$ to be equipped with an
  \defn{instance equivalence}, which we define to be
  \begin{itemize}
    \item a universe $\V,$ along with
    \item for each type $A \in \U,$ a reflexive, symmetric, and transitive $\V$-valued
    meta-relation $(\equiv)_A$ on $S_A.$ (In its infix form, we just write ``$\equiv$''.)
  \end{itemize}
\end{definition}

We say that ``$\U$ has instances equivalences in $\V$.''

The idea behind attaching an instance equivalence to a universe is that different universes
have different `natural' notions of equivalence of the instances of their
types.\footnote{When formalizing this theory in HoTT, it should be possible to assume that
all of these instance equivalences are actually equalities.}
Therefore, we will explicitly define instance equivalences for some, but not all, of the
examples given in section \ref{sec:universes}.

\begin{itemize}
  \item For every collection $\C$ of sets, the universe $\Set_\C$ has instance equivalences
  in $\Bool,$ by converting the set-theoretic equality relation on each set in $\C$ to a
  meta-relation as specified in the previous section.\\
  Note that the equivalences of both $\Bool$ and $\Unit$ are then actually in $\Unit$ (as a
  subuniverse of $\Bool$), as each type in $\Bool$ and $\Unit$ has at most one instance.
  \item Universes of simple algebraic structures (groups, rings, vector spaces, etc.)\ have
  the same instance equivalences as $\Set.$ More specifically, universes of algebraic
  structures inherit their instance equivalences from $\Set$ if their elements do not have
  any internal structure that suggests a different definition of instance equivalence.
  This generalizes to structures built on universes other than $\Set.$
  \item In the universe of categories, we define $a \equiv b$ to be the set of
  isomorphisms from $a$ to $b,$ as described in the previous section. Therefore, the
  universe of categories has instance equivalences in $\Set$ instead of $\Bool.$\\
  (Similarly, higher categories generally have instance equivalences in some universe of
  categories or higher categories. We will not investigate this in detail, but it is likely
  that some concepts in this document correspond closely to higher category theory.)
  \item In section \ref{sec:equivalences} we will give a definition of equivalence of types in
  a universe, and this will also be our definition of instance equivalences of universes of
  universes.
  \item Subuniverses inherit instance equivalences from their superuniverse.
  \item If $\U$ has instance equivalences in $\V,$ and $\U'$ has instance equivalences in
  $\V',$ then the product and sum universes $\U \times \U'$ and $\U \uplus \U'$ have instance
  equivalences in $\V \times \V'$ and $\V \uplus \V',$ respectively.
\end{itemize}

We will make sure that in the universes we deal with, for every sequence of universes
$\U_1, \U_2, \ldots,$ where each $\U_k$ has instance equivalences in $\U_{k+1},$ there is
a $k$ such that $\U_k = \U_{k+1} = \cdots = \Unit.$ However, at this point we do not consider
the interactions between the steps in such a sequence.\footnote{Readers familiar with HoTT may
have noticed that instance equivalences should have the structure of a higher groupoid that is
reflected in this sequence. However, we want to specify our assumptions in a more fine-grained
manner.}

\section{Functors}
\label{sec:functors}

The next piece of structure that we attach to universes -- and the first that lets us derive
some concrete results -- is a generalization of functions to what we call \defn{functors}.
Although functors between categories are indeed one special case of this definition, the
conditions are much weaker.

\begin{definition}
  For universes $\U = (I, (S_A)_{A \in I})$ and $\V = (J, (T_B)_{B \in J}),$ a
  \defn{functor type} from $A \in \U$ to $B \in \V$ is a type $(A \to B)$ in a universe $\W$
  with the following two properties:
  \begin{itemize}
    \item For every instance $F : A \to B$ (which we call a \defn{functor}) we have a
    function $\apply_{ABF} : S_A \to T_B.$ Given $a : A,$ we will abbreviate
    ``$\apply_{ABF}(a)$'' to ``$F(a).$''
    \item Moreover, $\apply_{ABF}$ must respect instance equivalences: For each
    $a,b : A,$ we have a function $\congrArg_{ABFab}$ that maps instances of the type
    $a \equiv b$ to instances of $F(a) \equiv F(b).$\footnote{Although ideally we want
    $\congrArg$ to be a functor as well, recursively, at this point we do not make such an
    assumption.}
    For an equivalence $e : a \equiv b,$ we write ``$F(e)$'' for $\congrArg_{ABFab}(e)$ as
    well, matching the corresponding overloaded notation in category theory.
  \end{itemize}
  
  We say that we \defn{have functors from $\U$ to $\V$ in $\W$} if for every $A \in \U$ and
  $B \in \V$ we have a functor type $(A \to B) \in \W.$
  We say that a universe $\U$ has \defn{internal functors} if we have functors from $\U$ to
  $\U$ in $\U.$

  As is common practice, we define the symbol ``$\to$'' to be right-associative, i.e.\ the
  notation ``$A \to B \to C$'' stands for ``$A \to (B \to C).$'' We call such a functor $F$ a
  \defn{bifunctor}, and we write ``$F(a,b)$'' for ``$F(a)(b).$'' (In section \ref{sec:products},
  we will identify $A \to B \to C$ with $A \times B \to C,$ where $A \times B$ is a product
  type.)
\end{definition}

The definition of functors is so generic that we can, in principle, define functors between
many different types in many different universes. However, universes with internal functors
are much more rarer. Let us analyze a few examples.
\begin{itemize}
  \item The functors of $\Set$ are just functions, which respect equality and are obviously
  in $\Set$.
  \item The universe of categories has internal functors: For categories $\C$ and $\D,$ the
  (categorical) functors from $\C$ to $\D$ form a category $\D^\C,$ and we define the type
  $(\C \to \D)$ to be that category.\\
  We need to verify that functors respect instance equivalences. Recall that for objects
  $a$ and $b$ of either $\C$ or $\D,$ the type $a \equiv b$ is the set of isomorphisms from
  $a$ to $b.$ Indeed, functors map isomorphisms to isomorphisms.
  \item The same is true for the universe of groupoids, as a subuniverse of the universe of
  categories, because the category of functors between two groupoids is a groupoid. (For
  suitable definitions of instance equivalences, it should also generalize to higher
  categories and groupoids.)
  \item The morphisms of some, but not all, algebraic structures are also internal functors
  in our sense: In some cases morphisms of a class of structures are themselves instances
  of that class of structures, when operations on morphisms are defined `pointwise'.

  For example, if $f,g : S \to T$ are two morphisms of commutative semigroups, then we can
  define $f \star g$ to be the function that sends each $a \in S$ to $f(a) \ast g(a).$ This
  is easily verified to be a morphism as well, based on associativity and commutativity
  of $(\ast).$ Moreover $(\star)$ inherits associativity and commutativity from $(\ast),$
  turning the set of morphisms from $S$ to $T$ into a semigroup.

  We may investigate the necessary and sufficient conditions more generally later, but for
  now, the following non-exhaustive list of structures with internal functors will have to
  do:
  \begin{itemize}
    \item commutative semigroups, monoids, and groups
    \item modules over a ring
    \item vector spaces over a field
  \end{itemize}
  % TODO: Do commutative rings without 1 work?
  \item Continuous functions between topological spaces can be regarded as internal
  functors of a universe of topological spaces, by fixing a topology on them.
  \item The universe $\Unit$ only has a single type $1,$ so we must set $(1 \to 1) := 1.$
  The type $1$ has exactly one instance $\emptyset,$ so $\apply$ is completely
  defined by $\apply_{11\emptyset}(\emptyset) := \emptyset,$ and $\congrArg$ is completely
  defined by $\congrArg_{11\emptyset\emptyset\emptyset}(\emptyset) := \emptyset.$
  \item For $\Bool,$ we set
  \begin{align*}
    (0 \to 0) &:= 1,\\
    (0 \to 1) &:= 1,\\
    (1 \to 0) &:= 0,\\
    (1 \to 1) &:= 1,
  \end{align*}
  matching logical implication.\footnote{This can be regarded as a degenerate case of
  the Curry-Howard correspondence.} Since $0$ has no instances and $1$ only has
  $\emptyset,$ we need to define three functions $\apply_{00\emptyset},$
  $\apply_{01\emptyset},$ and $\apply_{11\emptyset}.$ The first two have empty domains,
  and the third is again completely defined by
  $\apply_{11\emptyset}(\emptyset) := \emptyset.$
\end{itemize}

\begin{definition}
  For universes $\U$ and $\V$ with functors in $\W,$ types $A \in \U$ and $B \in \V,$
  and a family $(t_a)_{a : A}$ of instances $t_a : B$ (i.e.\ a function from the set of
  instances of $A$ to the set of instances of $B$) we define the notation
  \begin{align*}
    F : A &\to     B\\
        a &\mapsto t_a
  \end{align*}
  to mean that $F$ is a functor from $A$ to $B,$ and that for each $a : A$ we have an instance
  equivalence
  \[\fndef{F}(a) : F(a) \equiv t_a.\]
  We call $\fndef{F}$ the \defn{definition of $F$}. If $\fndef{F}(a) = \id_B$ for all $a : A,$
  we call the definition \defn{strict}.

  We extend this notation to bifunctors: Given appropriate universes and types and a
  family $(t_{ab})_{a : A, b : B},$ we define
  \begin{align*}
    F : A \to B &\to     C\\
        (a,b)   &\mapsto t_{ab}
  \end{align*}
  to mean that $F$ is a functor from $A$ to $(B \to C),$ and that for each $a : A$ and $b : B$ we
  have an instance equivalence $\fndef{F}(a,b) : F(a,b) \equiv t_{ab}.$

  Likewise for \defn{trifunctors} $F : A \to B \to C \to D,$ and so on.
\end{definition}

Note that not every family of instances gives rise to a functor, even though the notation might
suggest it (intentionally, as we will see). We will now assert the existence of certain functors
axiomatically.

\subsection{Functor operations}
\label{sec:funop}

\begin{definition}
  We say that a universe $\U$ with internal functors has \defn{linear functor
  operations}\footnote{The words ``linear'' and ``affine'' refer to linear and affine logic.}
  if we have the following three functors and six instance equivalences for all types
  $A,B,C,D \in \U.$
  \vspace{1ex}
  \begin{gather*}
    \begin{aligned}
      \idFun_A : A &\to     A\\
                 a &\mapsto a
    \end{aligned}\\[1em]
    \begin{aligned}
      \revAppFun_{AB} : A \to (A \to B) &\to     B\\
                        (a,F)           &\mapsto F(a)
    \end{aligned}\\[1em]
    \begin{aligned}
      \compFun_{ABC} : (A \to B) \to (B \to C) \to A &\to     C\\
                       (F,G,a)                       &\mapsto G(F(a))
    \end{aligned}
  \end{gather*}

  Before stating the required equivalences, we derive two additional functors from $\revAppFun$
  and $\compFun.$
  To improve readability, we want to use the symbol ``$\circ$'' when $\compFun$ is applied to
  two arguments, and indeed the functor arrow $(\to)$ is a $\U$-valued meta-relation on the
  set of types, which, given linear functor operations, is
  \begin{itemize}
    \item reflexive with $\id_A := \idFun_A$ and
    \item transitive with $G \circ F := \compFun_{ABC}(F,G)$ for $F : A \to B$ and
    $G : B \to C.$
  \end{itemize}

  Now we define
  \begin{align*}
    \swapFun_{ABC} &:= \compFun_{B((B{\to}C){\to}C)(A{\to}C)}(\revAppFun_{BC}) \circ \compFun_{A(B{\to}C)C}\\
                   &: \begin{aligned}[t]
                        (A \to B \to C) \to B \to A &\to     C\\
                        (F,b,a)                     &\mapsto F(a,b)
                      \end{aligned}
  \end{align*}
  and
  \begin{align*}
    \revCompFun_{ABC} &:= \swapFun(\compFun_{ABC})\\
                      &: \begin{aligned}[t]
                           (B \to C) \to (A \to B) \to A &\to     C\\
                           (G,F,a)                       &\mapsto G(F(a))
                         \end{aligned}
  \end{align*}
  (omitting the subscript of $\swapFun$ when applying it to an argument)
  and assert the existence of the following instance equivalences.
  %
  \begin{align*}
    \nm{rightId}_{AB} &: \compFun_{AAB}(\idFun_A) \equiv \idFun_{A{\to}B}\\
    \nm{leftId}_{AB}  &: \revCompFun_{ABB}(\idFun_B) \equiv \idFun_{A{\to}B}\\
    \nm{swapT}_{AB}   &: \swapFun(\revAppFun_{AB}) \equiv \idFun_{A{\to}B}\\
    \nm{swapB'}_{ABC} &: \swapFun_{(B{\to}C)AC} \circ \compFun_{ABC} \equiv \revCompFun_{AB((B{\to}C){\to}C)}(\revAppFun_{BC})\\
    \nm{swapB}_{ABC}  &: \swapFun_{(A{\to}B)AC} \circ \revCompFun_{ABC} \equiv \revCompFun_{A((A{\to}B){\to}B)((A{\to}B){\to}C)}(\revAppFun_{AB}) \circ \revCompFun_{(A{\to}B)BC}\\
    \nm{assoc}_{ABCD} &: \compFun_{(B{\to}C)((C{\to}D){\to}(B{\to}D))((C{\to}D){\to}(A{\to}D))}(\compFun_{BCD}) \circ \revCompFun_{(C{\to}D)(B{\to}D)(A{\to}D)} \circ \compFun_{ABD} \equiv\\
                      &\:\ \ \revCompFun_{(B{\to}C)}(\compFun_{ACD}) \circ \compFun_{ABC}
  \end{align*}
\end{definition}

\begin{remark}
  When defining $\swapFun$ and $\revCompFun,$ we implicitly assumed that we can derive
  instance equivalences
  \[\fndef{\swapFun}(F,b,a) : \swapFun(F,b,a) \equiv F(a,b) \quad \text{for } F : A \to B \to C,\ b : B,\ a : A\]
  and
  \[\fndef{\revCompFun}(G,F,a) : \revCompFun(G,F,a) \equiv G(F(a)) \quad \text{for } G : B \to C,\ F : A \to B,\ a : A.\]
  In order to obtain these, we first establish one further aspect in which functors behave like
  functions.
\end{remark}

\begin{proposition}
  \label{prp:congrfun}
  Given linear functor operations, two functors $F,G : A \to B,$ an instance equivalence
  $e : F \equiv G,$ and an instance $a : A,$ we can obtain an instance equivalence
  $e(a) : F(a) \equiv G(a).$
\end{proposition}
\vspace{-1ex}
\begin{proof}
  The functor $\revAppFun_{AB}(a)$ must respect instance equivalences, so we have an equivalence
  \[\revAppFun_{AB}(a)(e) : \revAppFun_{AB}(a,F) \equiv \revAppFun_{AB}(a,G).\]
  Applying the definition of $\revAppFun_{AB}$ yields an equivalence of the desired type:
  \begin{align*}
    e(a) &:= \fndef{\revAppFun_{AB}}(a,G) \circ \revAppFun_{AB}(a)(e) \circ (\fndef{\revAppFun_{AB}}(a,F))^{-1}\\
         &: F(a) \equiv G(a).
    \qedhere
  \end{align*}
\end{proof}

Together with the other properties of instance equivalences, this proposition establishes
that when constructing an instance equivalence involving functors, we may freely rewrite
along other equivalences, i.e.\ substitute arbitrary subterms. Still, the result will be an
explicit construction, which may be important if e.g.\ equivalences are
isomorphisms.\footnote{In terms of type theory, we are simply doing proof-relevant mathematics.}

We will usually avoid spelling out the details of such constructions,\footnote{Explicit
constructions of all equivalences can be found in the Lean formalization.} but for
demonstration purposes we will explicitly construct $\fndef{\swapFun}$ now.

Recall that ``$\circ$'' is just a shorthand for $\compFun$ in reverse order. So for a given
$F : A \to B \to C,$ the term
$\swapFun(F) = (\compFun_{B((B{\to}C){\to}C)(A{\to}C)}(\revAppFun_{BC}) \circ \compFun_{A(B{\to}C)C})(F)$
is exactly the left side of an equivalence given by $\fndef{\compFun}$:
\begin{align*}
  e &:= \fndef{\compFun}(\compFun_{A(B{\to}C)C},\compFun_{B((B{\to}C){\to}C)(A{\to}C)}(\revAppFun_{BC}),F)\\
    &: \swapFun(F) \equiv \compFun_{A(B{\to}C)C}(F) \circ \revAppFun_{BC}.
\end{align*}
Applying proposition \ref{prp:congrfun} to $e$ and an instance $b : B,$ we obtain
\[e(b) : \swapFun(F,b) \equiv (\compFun_{A(B{\to}C)C}(F) \circ \revAppFun_{BC})(b).\]
The right side is again an application of $\compFun,$ so we have
\begin{align*}
  f &:= \fndef{\compFun}(\revAppFun_{BC},\compFun_{A(B{\to}C)C}(F),b)\\
    &: (\compFun_{A(B{\to}C)C}(F) \circ \revAppFun_{BC})(b) \equiv \revAppFun_{BC}(b) \circ F,
\end{align*}
and, applying transitivity of $(\equiv),$
\begin{align*}
  g &:= f \circ e(b)\\
    &: \swapFun(F,b) \equiv \revAppFun_{BC}(b) \circ F.
\end{align*}
Apply proposition \ref{prp:congrfun} to $g$ and an instance $a : A$ to obtain
\[g(a) : \swapFun(F,b,a) \equiv (\revAppFun_{BC}(b) \circ F)(a).\]
This time we have two relevant definitions
\begin{align*}
  h &:= \fndef{\compFun}(F,\revAppFun_{BC}(b))\\
    &: (\revAppFun_{BC}(b) \circ F)(a) \equiv \revAppFun_{BC}(b,F(a)),\\[1ex]
  i &:= \fndef{\revAppFun}(b,F(a))\\
    &: \revAppFun_{BC}(b,F(a)) \equiv F(a,b).
\end{align*}
Finally, we can apply transitivity twice to arrive at
\begin{align*}
  \fndef{\swapFun}(F,b,a) &:= i \circ h \circ g(a)\\
                          &: \swapFun(F,b,a) \equiv F(a,b).
\end{align*}

\begin{remarks}
  For a bifunctor $F : A \to B \to C,$ the bifunctor $\swapFun(F) : B \to A \to C$ behaves
  (up to instance equivalences) like $F$ with swapped arguments. So, informally speaking,
  a bifunctor is a bifunctor regardless of the order of its arguments.

  This should also help clarify the role of $\compFun$ and $\revCompFun.$ The existence
  of $\compFun$ ensures that we can not only compose two functors $F : A \to B$ and
  $G : B \to C$ to $G \circ F : A \to C,$ but also that composition itself is bifunctorial
  in $F$ and $G.$ $\revCompFun,$ then, is the corresponding bifunctor with reversed
  arguments, and in fact we could assert $\revCompFun$ as an axiom and derive $\compFun$
  from it instead.\footnote{Due to a minor technical detail, $\compFun$ leads to a slightly
  more convenient definition of $\swapFun.$}

  Similarly $\revAppFun$ says that for each $a : A,$ the application of $a$ to an
  $F : A \to B$ is functorial, and also that this application functor is functorial in
  $a.$

  Moreover, all of these functors can in fact be regarded as combinators \cite{combinators}
  in a simply-typed lambda calculus \cite{simply-typed-lambda-calculus}, so we use
  established names for these combinators as much as possible.
\end{remarks}

\vspace{1ex}
\begin{definition}
  We say that a universe $\U$ with internal functors has \defn{affine functor
  operations} if it has linear functor operations and additionally the following functor
  and equivalences for all types $A,B,C \in \U.$
  \begin{align*}
    \constFun_{AB} : B \to A &\to     B\\
                     (b,a)   &\mapsto b
  \end{align*}
  \begin{align*}
    \nm{rightConst}_{ABC} &: \compFun_{B(A{\to}B)(A{\to}C)}(\constFun_{AB}) \circ \revCompFun_{ABC} \equiv \revCompFun_{BC(A{\to}C)}(\constFun_{AC})\\
    \nm{leftConst}_{ABC}  &: \compFun_{C(B{\to}C)(A{\to}C)}(\constFun_{BC}) \circ \compFun_{ABC} \equiv \constFun_{(A{\to}B)(C{\to}A{\to}C)}(\constFun_{AC})
  \end{align*}
\end{definition}

\begin{definition}
  We say that a universe $\U$ with internal functors has \defn{full functor
  operations} if it has affine functor operations and additionally the following functor
  and equivalences for all types $A,B,C \in \U.$

  First we assert the existence of
  \begin{align*}
    \dupFun_{AB} : (A \to A \to B) \to A &\to     B\\
                   (F,a)                 &\mapsto F(a,a)
  \end{align*}
  and derive
  \begin{align*}
    \substFun_{ABC} &:= \revCompFun_{(A{\to}B{\to}C)(A{\to}A{\to}C)(A{\to}C)}(\dupFun_{AC}) \circ
                        \revCompFun_{A(B{\to}C)(A{\to}C)} \circ
                        \compFun_{ABC}\\
                    &: \begin{aligned}[t]
                         (A \to B) \to (A \to B \to C) \to A &\to     C\\
                         (F,G,a)                             &\mapsto G(a,F(a))
                       \end{aligned}
  \end{align*}
  and
  \begin{align*}
    \revSubstFun_{ABC} &:= \swapFun(\substFun_{ABC})\\
                       &: \begin{aligned}[t]
                            (A \to B \to C) \to (A \to B) \to A &\to     C\\
                            (G,F,a)                             &\mapsto G(a,F(a)).
                          \end{aligned}
  \end{align*}

  Then we assert the existence of the following equivalences.
  \begin{align*}
    \nm{dupC}_{AB}      &: \dupFun_{AB} \circ \swapFun_{AAB} \equiv \dupFun_{AB}\\
    \nm{dupK}_{AB}      &: \dupFun_{AB} \circ \constFun_{A(A{\to}B)} \equiv \idFun_{A{\to}B}\\
    \nm{dupW}_{AB}      &: \dupFun_{AB} \circ \dupFun_{A(A{\to}B)} \equiv \dupFun_{AB} \circ \revCompFun_{A(A{\to}A{\to}B)(A{\to}B)}(\dupFun_{AB})\\
    \nm{rightDup}_{ABC} &: \begin{aligned}[t]\compFun_{ABC} \circ \dupFun_{AB} &\equiv \revCompFun_{(B{\to}C)(A{\to}A{\to}C)(A{\to}C)}(\dupFun_{AC})\,\circ\\
                                                                               &\ \ \ \ \compFun_{(B{\to}C)((A{\to}B){\to}(A{\to}C))(A{\to}A{\to}C)}(\revCompFun_{ABC}) \circ \compFun_{A(A{\to}B)(A{\to}C)}\end{aligned}\\
    \nm{leftDup}_{ABC}  &: \compFun_{(A{\to}B{\to}B{\to}C)(A{\to}B{\to}C)(A{\to}C)}(\revCompFun_{A(B{\to}B{\to}C)(B{\to}C)}(\dupFun_{BC})) \circ \substFun_{ABC} \equiv\\
                        &\:\ \ \substFun(\substFun_{ABC},\compFun_{(A{\to}B{\to}B{\to}C)(A{\to}B{\to}C)(A{\to}C)} \circ \substFun_{AB(B{\to}C)})
  \end{align*}
\end{definition}

\begin{lemma}
  \label{lem:extensional}
  The axioms $\nm{rightId},\nm{leftId},\ldots$ hold trivially (whenever the functors
  referenced in those axioms are defined) in any universe that satisfies the following
  extensionality condition:

  If $A$ and $B$ are types, $F,G : A \to B$ are functors, and for every $a : A$ we have
  an equivalence $e(a) : F(a) \equiv G(a),$ then there is also an equivalence
  $e : F \equiv G.$
\end{lemma}

(Note that proposition \ref{prp:congrfun} says that the converse is always true in
a universe with linear functor operations.)

\begin{proof}
  Under the extensionality condition, the equivalence
  \[\nm{rightId}_{AB} : \compFun_{AAB}(\idFun_A) \equiv \idFun_{A{\to}B}\]
  exists if for every $F : A \to B$ we have an equivalence
  \[\nm{rightId}_{AB}(F) : F \circ \idFun_A \equiv \idFun_{A{\to}B}(F).\]
  By straightforward operations on equivalences and another application of the
  extensionality condition, this equivalence exists if for every $a : A$ we have an
  equivalence
  \[\nm{rightId}_{AB}(F,a) : F(a) \equiv F(a),\]
  which is given by $\id_{F(a)}.$

  The other axioms are analogous.
\end{proof}

\begin{theorem}
  \label{thm:funop}
  The universes with internal functors that are listed in section \ref{sec:functors} have the
  following functor operations.
  \begin{itemize}
    \item $\Unit,$ $\Bool,$ $\Set,$ and the universes of categories and groupoids have
    full functor operations.
    \item The listed universes of algebraic structures have linear functor operations.
  \end{itemize}
\end{theorem}

\begin{proof}
  We will give explicit proofs for some important cases; the remaining axioms and
  universes are analogous.
  %
  \begin{itemize}
    \item In $\Unit,$ we take each functor to be the single instance $\emptyset : 1.$
    All axioms are trivially satisfied.
    %
    \item For $\Bool,$ we can show that all functors exist by doing a case-by-case
    analysis on the types $A,B,\ldots$ being either $0$ or $1.$ This can be simplified by
    treating ``$\to$'' as implication and observing that all implications hold, or even
    further by applying the Curry-Howard correspondence \cite{curry-howard}.\\
    Since $\Bool$ has instance equivalences in $\Unit,$ those are trivially satisfied.
    %
    \item The functors of $\Set$ are just functions. Since functions are
    extensional,\footnote{The theory can also be formalized in a logic without function
    extensionality by \emph{defining} functors between sets to be extensional functions.
    Alternatively/additionally, it is possible to define a universe of setoids, which
    is similar to $\Set$ except that equality is replaced with an equivalence relation.}
    the axioms $\nm{rightId},\nm{leftId},\ldots$ hold by lemma \ref{lem:extensional}.
    %
    \item To show how to construct the required functors in universes of
    structures, we will take $\constFun_{\C\D}$ for categories $\C$ and $\D$ as a
    simple but not completely trivial example.

    The definition of $\constFun_{\C\D}$ says that for objects $c$ of $\C$ and $d$ of
    $\D,$ $\constFun_{\C\D}(d,c)$ must be isomorphic to $d.$ In many cases, we do not
    actually need this flexibility; we can construct a functor that maps strictly to
    $d.$ That is, we show that the expression defining the functor is indeed functorial
    in all arguments starting from the last.\footnote{In the Lean formalization, the
    axioms are already divided into such individual steps, which is often more useful.}

    So the first step is to show that for a fixed object $d$ of $\D$ we have a functor
    \begin{align*}
      K_d : \C &\to     \D\\
            c  &\mapsto d,
    \end{align*}
    i.e. for objects $c,c'$ of $\C$ and a morphism $f : c \to c'$ we need to
    provide a morphism $K_d(f) : K_d(c) \to K_d(c').$ But $K_d(c)$ and $K_d(c')$
    are both $d,$ so we can define $K_d(f)$ to be the identity morphism on $d.$ (Then
    $K_d$ is just the constant functor, of course.)

    The second step is to show that the expression $K_d$ is functorial in $d,$ and
    this will give the desired functor
    \begin{align*}
      \constFun_{\C\D} : \D &\to     \D^\C\\
                         d  &\mapsto K_d.
    \end{align*}
    For objects $d,d'$ of $\D$ and a morphism $f : d \to d',$ we need to provide a
    natural transformation $\constFun_{\C\D}(f) : K_d \Rightarrow K_{d'}.$
    Thus, for each object $c$ of $\C$ we need to give a morphism
    $g_c : K_d(c) \to K_{d'}(c).$ Since $K_d(c) = d$ and $K_{d'}(c) = d',$ we can
    take $g_c := f.$ ($\constFun_{\C\D}$ is known as the diagonal functor.)
    %
    \item The least straightforward case is the construction of $\dupFun_{\C\D}$ for
    categories $\C$ and $\D.$ Following the same strategy as before, first we fix a
    functor $F : \C \to \D^\C$ and need to construct a functor
    \begin{align*}
      W_F : \C &\to     \D\\
            c  &\mapsto F(c)(c).
    \end{align*}
    So for objects $c,c'$ of $\C$ and a morphism $f : c \to c'$ we need to provide
    a morphism $W_F(f) : F(c)(c) \to F(c')(c').$ Since $F(f)$ is a natural
    transformation, the two choices for this morphism are equal:
    \[W_F(f) := (F(f))_{c'} \circ F(c)(f) = F(c')(f) \circ (F(f))_c.\]
    $W_F$ is indeed a functor: We have
    \[W_F(\id_c) = (\id_{F(c)})_{c} \circ \id_{F(c)(c)} = \id_{F(c)(c)}\]
    and for morphisms $f : c \to c'$ and $g : c' \to c''$ in $\C$
    \begin{align*}
      W_F(g \circ f) &= (F(g \circ f))_{c''} \circ F(c)(g \circ f)\\
                     &= (F(g))_{c''} \circ (F(f))_{c''} \circ F(c)(g) \circ F(c)(f)\\
                     &= (F(g))_{c''} \circ F(c')(g) \circ (F(f))_{c'} \circ F(c)(f) \quad \text{by naturality of $F(f)$}\\
                     &= W_F(g) \circ W_F(f).
    \end{align*}
    Now we need to show that $W_F$ is functorial in $F$ to obtain
    \begin{align*}
      \dupFun_{\C\D} : (\D^\C)^\C &\to     \D^\C\\
                       F          &\mapsto W_F.
    \end{align*}
    Given two functors $F,F' : \C \to \D^C$ and a natural transformation
    $\eta : F \Rightarrow F',$ we need to provide a natural transformation
    $\dupFun_{\C\D}(\eta) : W_F \Rightarrow W_{F'}.$ We set
    $(\dupFun_{\C\D}(\eta))_c := (\eta_c)_c$ for each object $c$ of $\C,$
    and need to verify that this is natural in $c.$ Indeed, for every
    morphism $f : c \to c'$ we have
    \begin{align*}
      (\eta_{c'})_{c'} \circ W_F(f) &= (\eta_{c'} \circ F(f))_{c'} \circ F(c)(f)\\
                                    &= (F'(f) \circ \eta_c)_{c'} \circ F(c)(f) \quad \text{by naturality of $\eta$}\\
                                    &= (F'(f))_{c'} \circ (\eta_c)_{c'} \circ F(c)(f)\\
                                    &= (F'(f))_{c'} \circ F'(c)(f) \circ (\eta_c)_c \quad \text{by naturality of $\eta_c$}\\
                                    &= W_{F'}(f) \circ (\eta_c)_c.
    \end{align*}
    It is easily verified that $\dupFun_{\C\D}$ respects identity and
    composition of natural transformations.
    \item Although lemma \ref{lem:extensional} does not apply to the universe of
    categories, the proof strategy for $\nm{rightId},\ldots$ is the same
    as in the proof of that lemma. The difference is that at each step where we
    would apply the extensionality condition, instead we need to verify that the
    equivalences $e(a)$ are natural in $a.$ \qedhere
  \end{itemize}
\end{proof}

\begin{conjecture}
  Theorem \ref{thm:funop} generalizes at least to $n$-groupoids and possibly
  also to $n$-categories.
\end{conjecture}

\begin{conjecture}
  Topological spaces satisfying some mild conditions (compactly generated Hausdorff?)
  also have full functor operations.
\end{conjecture}

\subsection{Functoriality algorithm}

After having shown that several important universes do in fact have linear or even full
functor operations, we will now describe an algorithm to prove functoriality
automatically, i.e.\ to obtain a functor that matches a given definition.

This algorithm is actually just a slight adaptation of the well-known algorithm to
transform lambda abstractions into terms built from combinators \cite{combinators}. In a
simply-typed lambda calculus, this algorithm always terminates. So as long as one is
not interested in the specific behavior of the functor (beyond how it maps instances),
there is no need to execute the algorithm explicitly -- verifying the preconditions
in the following proposition is sufficient.

\begin{proposition}
  \label{prp:functoriality}
  Let $\U$ be a universe with internal functors and (at least) linear functor
  operations, $A_1,\ldots,A_n$ and $B$ be types of $\U,$ and
  $(t_{a_1 \ldots a_n})_{a_k : A_k}$ be a family of instances $t_{a_1 \ldots a_n} : B$
  that are one of the following:
  \begin{itemize}
    \item a constant independent of all $a_k,$
    \item one of the variables $a_k,$ or
    \item a functor application $G_{a_1 \ldots a_n}(b_{a_1 \ldots a_n})$ such that
    both $G_{a_1 \ldots a_n}$ and $b_{a_1 \ldots a_n}$ recursively follow the same
    rules.\footnote{Formally, the rules generate a family $(T_B)_{B \in \U}$ of
    sets $T_B \subseteq F_B,$ where $F_B$ is the set of functions from
    $S_{A_1} \times \dots \times S_{A_n}$ to $S_B,$ and $S_A$ is the set of
    instances of $A$ for each $A \in \U.$}
  \end{itemize}
  Then we have a functor
  \begin{align*}
    F : A_1 \to \dots \to A_n &\to     B\\
        (a_1 \ldots a_n)      &\mapsto t_{a_1 \ldots a_n}
  \end{align*}
  if the following additional constraints are satisfied.
  \begin{itemize}
    \item If $\U$ only has linear functor operations (but does not have affine
    functor operations), each variable $a_k$ must occur exactly once in $t_{a_1 \ldots a_n}.$
    \item If $\U$ only has affine functor operations (but does not have full
    functor operations), each variable $a_k$ must occur at most once in $t_{a_1 \ldots a_n}.$
  \end{itemize}
\end{proposition}

\begin{proof}
  First, we reduce definitions of bifunctors to definitions of functors; and analogously
  trifunctors to bifunctors, and so on. This principle closely resembles the proof
  strategy in theorem \ref{thm:funop}. To obtain a bifunctor
  \begin{align*}
    F : A_1 \to A_2 &\to     B\\
        (a_1,a_2)   &\mapsto t_{a_1a_2},
  \end{align*}
  first recursively obtain the functor
  \begin{align*}
    F_{a_1} : A_2 &\to     B\\
              a_2 &\mapsto t_{a_1a_2}
  \end{align*}
  for constant $a_1 : A_1.$
  Then recursively obtain the functor
  \begin{align*}
    F' : A_1 &\to     (A_2 \to B)\\
         a_1 &\mapsto F_{a_1}.
  \end{align*}
  Finally set $F := F',$ apply proposition \ref{prp:congrfun} to $\fndef{F'}$ to obtain
  an equivalence $\fndef{F'}(a_1)(a_2) : F(a_1,a_2) \equiv F_{a_1}(a_2),$ and set
  $\fndef{F}(a_1,a_2) := \fndef{F_{a_1}}(a_2) \circ \fndef{F'}(a_1)(a_2).$

  Due to this reduction, we can limit ourselves to the simple case
  \begin{align*}
    F : A &\to     B\\
        a &\mapsto t_a
  \end{align*}
  and perform a (non-exhaustive and non-unique) case split on $t_a.$

  \begin{longtable}{ll|l}
    Desired result & & $F$\\
    \hline\hline
    \rule{0pt}{2em}
    $\begin{aligned}
      F : A &\to     B\\
          a &\mapsto b
    \end{aligned}$ &
    \parbox{3cm}{for $b : B$ (constant \\ with respect to $a$)} &
    $\constFun_{AB}(b)$\\
    \hline
    \rule{0pt}{2em}
    $\begin{aligned}
      F : A &\to     A\\
          a &\mapsto a
    \end{aligned}$ & &
    $\idFun_A$\\
    \hline
    \rule{0pt}{2em}
    $\begin{aligned}
      F : A &\to     B\\
          a &\mapsto G(a)
    \end{aligned}$ &
    for $G : A \to B$ &
    $G$\\
    \hline
    \rule{0pt}{2em}
    $\begin{aligned}
      F : A &\to     C\\
          a &\mapsto G(b_a)
    \end{aligned}$ &
    \parbox{3cm}{for $b_a : B$ \\ and $G : B \to C$} &
    $\compFun_{ABC}(H,G)$ with
    $\begin{aligned}
      H : A &\to     B\\
          a &\mapsto b_a
    \end{aligned}$\\
    \hline
    \rule{0pt}{2em}
    $\begin{aligned}
      F : (B \to C) &\to     C\\
          G         &\mapsto G(b)
    \end{aligned}$ &
    for $b : B$ &
    $\revAppFun_{BC}(b)$\\
    \hline
    \rule{0pt}{2em}
    $\begin{aligned}
      F : A &\to     C\\
          a &\mapsto G_a(b)
    \end{aligned}$ &
    \parbox{3cm}{for $b : B$ \\ and $G_a : B \to C$} &
    $\swapFun_{ABC}(G,b)$ with
    $\begin{aligned}
      G : A &\to     (B \to C)\\
          a &\mapsto G_a
    \end{aligned}$\\
    \hline
    \rule{0pt}{2em}
    $\begin{aligned}
      F : A &\to     B\\
          a &\mapsto G_a(a)
    \end{aligned}$ &
    for $G_a : A \to B$ &
    $\dupFun_{AB}(G)$ with
    $\begin{aligned}
      G : A &\to     (A \to B)\\
          a &\mapsto G_a
    \end{aligned}$\\
    \hline
    \rule{0pt}{3em}
    $\begin{aligned}
      F : A &\to     C\\
          a &\mapsto G_a(b_a)
    \end{aligned}$ &
    \parbox{3cm}{for $b_a : B$ \\ and $G_a : B \to C$} &
    \parbox{6cm}{
      $\substFun_{ABC}(H,G)$ with \\[1ex]
      $\begin{aligned}
        H : A &\to     B\\
            a &\mapsto b_a
      \end{aligned}$
      and
      $\begin{aligned}
        G : A &\to     (B \to C)\\
            a &\mapsto G_a
      \end{aligned}$
    }
  \end{longtable}

  In all cases except the first two, $t_a$ is a functor application. In fact, the
  last case is the most general possible functor application, and in a universe with
  full functor operations, all other cases of functor applications may be regarded as
  mere optimizations.\\
  Note that a functor application with multiple arguments $F(a_1,\ldots,a_n)$ is
  really an application of the functor $F(a_1,\ldots,a_{n-1})$ to the argument $a_n,$
  and must be treated as such.

  One piece of information missing from the table is that the algorithm must produce
  not only the functor $F$ but also an instance equivalence
  $\fndef{F}(a) : F(a) \equiv t_a$ for each $a : A.$ This equivalence is obtained by
  composing the definition of the combinator with the definitions of the recursively
  obtained functors that are passed to the combinator as arguments (if any).
\end{proof}

\begin{remark}
  The algorithm may produce terms of the form $\swapFun(\compFun,\ldots)$ or
  $\swapFun(\substFun,\ldots).$ By the definitions of $\revCompFun$ and $\revSubstFun,$
  these can be replaced with $\revCompFun(\ldots)$ and $\revSubstFun(\ldots),$
  respectively.
\end{remark}

\begin{example}
  Let us consider the simple case where we want to compose a bifunctor
  $F : A \to B \to C$ with a functor $G : C \to D.$ This can be done in
  two different ways: We can either construct this composition for fixed but
  arbitrary $F$ and $G,$ or we can define it as a functor taking $F$ and $G$ as
  arguments.
  
  For fixed $F$ and $G,$ the functor we want to construct is
  \begin{align*}
    H_{FG} : A \to B &\to     D\\
             (a,b)   &\mapsto G(F(a,b)).
  \end{align*}
  The term $G(F(a,b))$ only consists of functor applications, references to the
  constants $F$ and $G,$ and references to the variables $a$ and $b,$ so we
  know that the functoriality algorithm can produce a functor matching this
  definition. Since each variable occurs in this term exactly once, the
  definition is valid in every universe with linear functor operations. If we
  actually execute the algorithm, we find that it outputs
  \[H_{FG} := \revCompFun_{BCD}(G) \circ F\]
  and
  \begin{align*}
    \fndef{H_{FG}}(a,b) &:= \fndef{\revCompFun_{BCD}}(G,F(a),b) \circ \fndef{\compFun_{A(B{\to}C)(B{\to}D)}}(F,\revCompFun_{BCD}(G),a)(b)\\
                        &: H_{FG}(a,b) \equiv G(F(a,b)).
  \end{align*}

  We can now interpret this construction in specific universes, for example:
  \begin{itemize}
    \item In the universe of categories:\\
    If $\A,\B,\C,\D$ are categories and $F : \A \to \C^\B$ and $G : \C \to \D$
    are functors, then we have a functor $H : \A \to \D^\B$ such that
    $H(a)(b)$ is isomorphic to $G(F(a)(b))$ for objects $a$ of $\A$ and $b$ of
    $\B.$
    \item In the universe of vector spaces over a field:\\
    If $V,W,X,Y$ are vector spaces over $K,$ $f$ is a linear map from $V$
    to the space of linear maps from $W$ to $X,$ and $g$ is a linear map
    from $X$ to $Y,$ then we have a linear map $h$ from $V$ to the space of
    linear maps from $W$ to $Y$ such that $h(v)(w) = g(f(v)(w))$ for vectors
    $v$ of $V$ and $w$ of $W.$
  \end{itemize}

  If instead we want to construct a functor that takes $F$ and $G$ as
  arguments, we can either execute the functoriality algorithm directly for
  \begin{align*}
    H : (A \to B \to C) \to (C \to D) \to A \to B &\to     D\\
        (F,G,a,b)                                 &\mapsto G(F(a,b)),
  \end{align*}
  or we can use the previous result and construct
  \begin{align*}
    H : (A \to B \to C) \to (C \to D) &\to     (A \to B \to D)\\
        (F,G)                         &\mapsto H_{FG} = \revCompFun_{BCD}(G) \circ F.
  \end{align*}
  The algorithm (always) produces the same result in both cases, which is
  \[H := \compFun_{(C{\to}D)((B{\to}C){\to}(B{\to}D))(A{\to}B{\to}D)}(\revCompFun_{BCD}) \circ \compFun_{A(B{\to}C)(B{\to}D)}.\]
\end{example}

\begin{remark}
  The utility of the functoriality algorithm can be a bit subtle, especially when dealing
  with concrete universes such as the universe of categories. As a rule of thumb, it can
  be used to prove functoriality of terms where all of the objects that appear in the term
  are already functorial. Or, from a reverse point of view, it eliminates the need to
  compose and otherwise manipulate functors explicitly -- instead, functors may simply be
  written as expressions that specify how to map objects, leaving the rest implicit.

  The algorithm becomes even more useful by incorporating further structure that can be
  described abstractly in terms of universes and functors. Then, similarly to the example
  above, we can algorithmically construct functors that involve such structure, and the
  resulting construction will be valid in many universes. Whenever something is
  ``obviously functorial,'' it probably has a universe-based interpretation so that
  functoriality indeed does not need to be proved.
\end{remark}

\subsection{Functor universe}
\label{sec:functor-universe}

In the universes we covered so far, the relationship between a type and the set of its
instances was always very straightforward (although they are truly equal only in $\Set_\C$).
In the universe that we are going to define now, we will need to be more careful about the
distinction: Recall that a type is just a member of an index set, and its instances are
actually defined by a family of sets that are indexed by types.

\begin{definition}
  Let $\U$ and $\V = (I, (S_B)_{B \in I})$ and $\W = (J, (T_C)_{C \in J})$ be universes
  such that we have functors from $\U$ to $\V$ in $\W,$ and let $A \in \U.$
  We define the \defn{functor universe} $\V^A$ to be the pair
  \[\V^A := (I, (T_{A \to B})_{B \in I}).\]
  That is,
  \begin{itemize}
    \item the types (or type indices, to be explicit) of $\V^A$ are the same as the types
    of $\V,$ but
    \item the instances in $\V^A$ of a type $B \in \V$ are actually functors from $A$ to $B.$
  \end{itemize}
  We let $\V^A$ inherit instance equivalences from $\W.$
\end{definition}

If types $B,C,\ldots \in \V$ are also types of $\V^A$ and vice versa, then the symbols
``$:$'' and ``$\to$'' become ambiguous. To avoid having to annotate them with universes, we
adopt the purely notational convention that for each type $B \in \V$ we define $B^A := B$
except that $B^A$ should be understood as a type in $\V^A.$ (Note that we do \emph{not}
extend this convention to instances of types; instead we will use the same notation for an
embedding operation.)

So ``$b : B$'' is always an abbreviation for ``$b :_\V B,$'' whereas ``$F : B^A$'' is an
abbreviation for ``$F :_{\V^A} B,$'' so that $F$ is a functor from $A$ to $B,$ not an
instance of $B.$

\subsubsection*{Full functor operations}

We will first concentrate on the case where we have a single universe $\U$ with internal
functors and full functor operations, and a type $A \in \U.$

\begin{proposition}
  \label{prp:fun-univ-full}
  In this case, $\U^A$ also has internal functors, defined by $(B^A \to C^A) := (B \to C)^A$
  for $B,C \in \U.$
\end{proposition}
\vspace{-1ex}
\begin{proof}
  For a functor $G : B^A \to C^A,$ which is also an instance of the type $A \to B \to C,$
  and an instance $F : B^A,$ which is also an instance of $A \to B,$ we define their functor
  application in $\U^A$ by $G(F) := \revSubstFun_{ABC}(G,F).$ This definition
  respects instance equivalences because it is an application of the functor
  $\revSubstFun_{ABC}(G).$
\end{proof}

\begin{proposition}
  \label{prp:fun-univ-embed-map}
  $\U$ embeds into $\U^A$: For each type $B \in \U$ and instance $b : B,$ we have
  a corresponding instance $b^A := \constFun_{AB}(b) : B^A.$ This embedding
  respects instance equivalences and functor application, up to instance equivalence.
\end{proposition}
\vspace{-1ex}
\begin{proof}
  As a functor, $\constFun_{AB}$ respects instance equivalences.
  Moreover, for $G : B \to C$ and $b : B$ with $B,C \in \U$ we can derive an equivalence
  \[\nm{embedMap}(G,b) : G^A(b^A) = \revSubstFun_{ABC}(\constFun_{A(B{\to}C)}(G),\constFun_{AB}(b)) \equiv
    \constFun_{AC}(G(b)) = (G(b))^A\]
  as follows.
  First, from $\nm{rightConst}$ and $\nm{dupK}$ we can derive the more generic equivalence
  \[\nm{leftSK}(G,F) : G^A(F) = \revSubstFun_{ABC}(\constFun_{A(B{\to}C)}(G),F) \equiv G \circ F\]
  for every $F : A \to B$ and $G : B \to C.$
  Then setting $F := \constFun_{AB}(b)$ yields $\nm{embedMap}$ via a second application
  of $\nm{rightConst}.$
\end{proof}

\begin{proposition}
  \label{prp:fun-univ-full-funop}
  $\U^A$ has full functor operations, defined by $\idFun_{B^A} := (\idFun_B)^A,$
  $\revAppFun_{(B^A)(C^A)} := (\revAppFun_{BC})^A, \ldots$ for $B,C \in \U.$
\end{proposition}
\vspace{-1ex}
\begin{proof}
  Clearly these instances are functors of the correct type, and by $\nm{embedMap}$
  they map embedded instances of types in $\U$ to the correct values. However, we
  need to verify that they also map all other instances of $\U^A$ to the values
  specified by their definition, up to equivalence. E.g.\ for $\idFun_{B^A}$ we
  need to provide an equivalence
  \[\fndef{\idFun_{B^A}}(F) : \idFun_{B^A}(F) = \revSubstFun_{ABC}(\constFun_{AB}(\idFun_B),F) \equiv F\]
  for $F : B^A.$ This equivalence follows from $\nm{leftSK}$ (from the proof of
  proposition \ref{prp:fun-univ-embed-map}) and $\nm{leftId}.$

  Most proofs follow from the axioms in a similarly straightforward way. However,
  analogously to how the definition of $\idFun_{B^A}$ corresponds to $\nm{leftId}$
  in $\U,$ the definition of $\compFun_{(B^A)(C^A)(D^A)}$ corresponds to
  associativity of $\revSubstFun,$ which we do not directly assume as an axiom.
  Instead, since $\revSubstFun$ is defined in terms of $\compFun$ and $\dupFun,$ its
  associativity follows from associativity of $\compFun$ (given by $\nm{assoc}$)
  and the axioms that constrain $\dupFun.$

  Full proofs are contained in the Lean formalization and will therefore be
  omitted here.

  Instance equivalences $\nm{rightId}, \nm{leftId}, \ldots$ in $\U^A$ are trivially
  obtained from the corresponding equivalences in $\U$ by repeated application of
  $\nm{embedMap}.$
\end{proof}

\begin{proposition}
  \label{prp:fun-univ-lift-fun}
  If $G : B \to C$ ($B,C \in \U$) is a functor with definition
  \begin{align*}
    G : B &\to     C\\
        b &\mapsto t_b
  \end{align*}
  where $t_b$ follows the constraints in proposition \ref{prp:functoriality},
  then we can lift the family $(t_b)_{b : B}$ to a family $(T_F)_{F : B^A}$ of
  instances of $C^A,$ which gives a definition
  \begin{align*}
    G^A : B^A &\to     C^A\\
          F   &\mapsto T_F
  \end{align*}
  for the embedded functor $G^A.$
\end{proposition}

\begin{proof}
  We recursively define $T_F$ based on the three possibilities for $t_b.$
  \begin{itemize}
    \item If $t_b$ is a constant $c$ independent of $b,$ we set $T_F := c^A.$
    \item If $t_b = b,$ we set $T_F := F.$
    \item If $t_b$ is a functor application, we set $T_F$ to the application of
    the lifted functor to the lifted term.
  \end{itemize}
  Then, executing the functoriality algorithm for $(t_b)_{b : B}$ and
  $(T_F)_{F : B^A}$ gives results $G' : B \to C$ and $G'' : B^A \to C^A$ that
  only consist of functor applications of constant terms, such that each term
  $x$ in $G'$ corresponds exactly to $x^A$ in $G''.$ Thus by repeated application
  of $\nm{embedMap}$ we obtain an equivalence between $G'^A$ and $G''.$ Composing
  this equivalence with the definitions of $G,$ $G',$ and $G''$ yields the
  required equivalence $\fndef{G^A}(F) : G^A(F) \equiv T_F$ for $F : B^A.$
\end{proof}

\begin{proposition}
  \label{prp:fun-univ-lift-equiv}
  Let $B,C \in \U,$ $(t_b)_{b : B}$ and $(t'_b)_{b : B}$ be families of instances
  $t_b,t'_b : C,$ and $(e_b)_{b : B}$ be a family of instance equivalences
  $e_b : t_b \equiv t'_b$ that are one of the following:
  \begin{itemize}
    \item a constant independent of $b,$
    \item $\id_{t_b},$
    \item $f_b^{-1}$ for an equivalence $f_b : t'_b \equiv t_b$ that recursively
    follows the same rules,
    \item $g_b \circ f_b$ for equivalences $f_b : t_b \equiv s_b$ and
    $g_b : s_b \equiv t'_b$ such that $s_b,$ $f_b,$ and $g_b$ recursively
    follow the same rules,
    \item $G(f)$ for a functor $G : D \to C$ and an equivalence
    $f : s_b \equiv s'_b$ that recursively follows the same rules, or
    \item an application of a functor definition $\fndef{G}(b)$ for $G : B \to C.$
  \end{itemize}
  Then $(e_b)_{b : B}$ lifts to a family $(E_F)_{F : B^A}$ of equivalences
  $E_F : T_F \equiv T'_F,$ where $(T_F)$ and $(T'_F)$ are lifted from $(t_b)$
  and $(t'_b)$ according to proposition \ref{prp:fun-univ-lift-fun}.
\end{proposition}

\begin{proof}
  We recursively define $E_F$ based on the six possibilities for $e_b.$
  \begin{itemize}
    \item If $e_b$ is a constant $e : c \equiv c',$ define
    $E_F := \constFun_{AC}(e) : c^A \equiv c'^A.$
    \item If $e_b = \id_{t_b},$ set $E_F := \id_{T_F}.$
    \item If $e_b$ is $f_b^{-1}$ or $g_b \circ f_b,$ obtain $E_F$ by recursion.
    \item If $e_b = G(f),$ set $E_F := G^A(H)$ where $H$ is obtained recursively
    from $f.$
    \item If $e_b = \fndef{G}(b)$ set $E_F := \fndef{G^A}(F).$ \qedhere
  \end{itemize}
\end{proof}

\begin{corollary}
  \label{cor:fun-univ-lift-equiv}
  Let $G,H : B \to C$ be functors with $B,C \in \U,$ and $(e_b)_{b : B}$ be a
  family of instance equivalences $e_b : G(b) \equiv H(b)$ that adhere to the
  constraints in proposition \ref{prp:fun-univ-lift-equiv}. Then $(e_b)_{b : B}$
  lifts to a family $(E_F)_{F : B^A}$ of equivalences $E_F : G^A(F) \equiv H^A(F).$
\end{corollary}

\vspace{1ex}
Thus, the functor universe $\U^A$ inherits all properties from $\U,$ but it
additionally comes with a specific instance $\idFun_A : A^A$ which can be
regarded as an adjoined element of type $A$ (similar to the symbol $X$ in a
polynomial ring $R[X]$). Using $\idFun_A,$ we have the following correspondence
between $\U^A$ and the functoriality algorithm for $\U$: When defining a functor
\begin{align*}
  F : A &\to     B\\
      a &\mapsto t_a
\end{align*}
with a family $(t_a)_{a : A}$ of instances, we can eliminate the variable
$a : A$ by lifting $(t_a)_{a : A}$ to $(T_G)_{G : A^A}$ and setting $F := T_{\idFun_A}.$
The functor $F$ obtained in this way is equivalent to the functor obtained from
the functoriality algorithm because of the following proposition (which is quite
similar to how evaluating a polynomial $f \in R[X]$ at $X$ yields $f$ itself).
\begin{proposition}
  For every $B \in \U$ and $F : A \to B$ we have an equivalence
  \[\nm{embedId}(F) : F^A(\idFun_A) \equiv F.\]
\end{proposition}
\vspace{-2ex}
\begin{proof}
  By $\nm{leftSK}$ and $\nm{rightId}.$
\end{proof}

\subsubsection*{Linear and affine functor operations}

Now let $\U$ be any universe with at least linear functor operations. If $\U$ does
not have full functor operations, then $\U^A$ does not have internal functors, but
we can either apply a constant functor (i.e.\ in $\U$) to a variable argument
(i.e.\ in $\U^A$) or vice versa.

\begin{proposition}
  \label{prp:fun-univ-linear}
  We have functors from $\U^A$ to $\U^A$ in $\U,$ defined by $(B^A \to C^A) := (B \to C)$
  for $B,C \in \U.$ Moreover, we have functors from $\U$ to $\U^A$ in $\U^A,$
  defined by $(B \to C^A) := (B \to C)^A.$
\end{proposition}
\vspace{-1ex}
\begin{proof}
  For a functor $G : B^A \to C^A,$ which by definition is just an instance of
  $B \to C,$ and an instance $F : B^A,$ we define their functor application by
  $G(F) := G \circ F.$ For a functor $G : B \to C^A,$ which is an instance of
  $A \to B \to C,$ and an instance $b : B,$ we define
  $G(b) := \swapFun_{ABC}(G,b).$
\end{proof}

We can unify these functors within a sum universe that additionally includes an
empty type.

\begin{definition}
  For a universes $\U,\V,\W$ such that we have functors from $\U$ to $\V$ in $\W,$
  and a type $A : \U,$ we define the \defn{optional functor universe} $\V^{A?}$ to
  be
  \[\V^{A?} := \V \uplus \V^A \uplus \Set_{\{0\}}.\]
  That is, each type in $\V^{A?}$ is either
  \begin{itemize}
    \item a type $B \in \V,$
    \item a functor type $B^A \in \V^A,$ or
    \item the empty type $0.$
  \end{itemize}
\end{definition}

\begin{proposition}
  For a universe $\U$ with internal functors and at least linear functor operations,
  $\U^{A?}$ has internal functors as follows. For $B,C \in \U,$ we set
  \begin{itemize}
    \item $(B \to C)$ in $\U^{A?}$ to be the same as $(B \to C)$ in $\U,$
    \item $(B \to C^A) := (B \to C)^A,$
    \item $(B^A \to C^A) := \begin{cases}
      (B \to C)^A & \text{if $\U$ has full functor operations}\\
      (B \to C)   & \text{otherwise,}
    \end{cases}$
    \item $(X \to Y) := 0$ for all $X,Y \in \V^{A?}$ not covered above.
  \end{itemize}
  Functor application is defined as in propositions \ref{prp:fun-univ-full} and
  \ref{prp:fun-univ-linear}.
\end{proposition}

\begin{definition}
  For $B,C \in \U$ and $G : B \to C,$ we define
  \[G^{A?} := \begin{cases}
    G^A & \text{if $\U$ has full functor operations}\\
    G   & \text{otherwise.}
  \end{cases}\]
\end{definition}

\begin{proposition}
  $\nm{embedMap}$ in $\U^A$ generalizes to
  \[\nm{embedMap}^?(G,b) : G^{A?}(b^A) \equiv (G(b))^A.\]
\end{proposition}

\begin{conjecture}
  \label{conj:fun-univ-linear}
  If $\U$ has linear/affine/full functor operations, then so does $\U^{A?}.$
\end{conjecture}

\begin{proposition}
  For every $B \in \U$ and $F : A \to B$ we have an equivalence
  \[\nm{embedId}^?(F) : F^{A?}(\idFun_A) \equiv F.\]
\end{proposition}

\subsection{Extensionality}
\label{sec:extensionality}

\begin{theorem}
  \label{thm:extensionality}
  Internal functors in a universe $\U$ with full functor operations (or unconditionally
  if conjecture \ref{conj:fun-univ-linear} holds) are ``extensional in practice:''
  If, for types $A,B \in \U$ and functors $F,G : A \to B,$ we have a family
  $(e_a)_{a : A}$ of instance equivalences $e_a : F(a) \equiv G(a)$ that adheres to the
  constraints of proposition \ref{prp:fun-univ-lift-equiv}, then we also have an
  equivalence $e : F \equiv G.$
\end{theorem}

(The constraints can be summarized as: $e_a$ is a term that can be derived from the
axioms that we have defined generically on universe-based structures.)

\begin{proof}
  By corollary \ref{cor:fun-univ-lift-equiv}, we can lift $(e_a)_{a : A}$ to a
  family $(E_H)_{H : A^A}$ of equivalences $E_H : F^A(H) \equiv G^A(H)$ in the
  functor universe $\U^A.$ Now set
  \begin{align*}
    e &:= \nm{embedId}(G) \circ E_{\idFun_A} \circ (\nm{embedId}(F))^{-1}\\
      &: F \equiv G. \qedhere
  \end{align*}
\end{proof}

\begin{remarks}
  The triviality or nontriviality of this theorem depends on the amount of structure
  that instance equivalences of $\U$ have. In the universe of categories, it is
  already quite significant: If for two functors $F,G : \C \to \D$ we can derive a
  family $(e_c)_{c \in \C}$ of isomorphisms from the axioms given in the previous
  sections, then $F$ and $G$ are naturally isomorphic.

  As with the functoriality algorithm, the usefulness of the theorem increases with
  additional structure that we define on universes. Whenever such structure lifts
  to the functor universe in a natural way (read: always), theorem \ref{thm:extensionality}
  also applies to functors and equivalences involving that structure.

  The result can also be interpreted as an extensionality theorem in lambda calculus,
  or more specifically in combinatory logic. A proof that extensionality in $\nm{SKI}$
  combinator calculus follows from five axioms is given in \cite{hindley-seldin},
  theorem 8.14. An analogous result (limited to simply-typed lambda calculus,
  however) can be obtained from our proof. Note that the main complexity is contained
  in proposition \ref{prp:fun-univ-full-funop}.
\end{remarks}

\begin{corollary}
  Whenever the functoriality algorithm offers multiple alternatives, there are instance
  equivalences between the resulting functors (in a universe with full functor
  operations, or unconditionally assuming conjecture \ref{conj:fun-univ-linear}).
\end{corollary}

\begin{remark}
  The following alternatives exist. (Brackets indicate that an alternative is redundant
  because it can also be regarded as an alternative of one or more other alternatives.)

  \begin{longtable}{ll|l}
    Case & & Alternatives\\
    \hline\hline
    \rule{0pt}{3em}
    $\begin{aligned}
      F : A &\to     C\\
          a &\mapsto G(b)
    \end{aligned}$ &
    \parbox{3cm}{for $b : B$ \\ and $G : B \to C$} &
    $\begin{array}{@{}l@{}}
      \constFun_{AC}(G(b))\\
      \compFun_{ABC}(\constFun_{AB}(b),G)\\
      \swapFun_{ABC}(\constFun_{A(B{\to}C)}(G),b)\\
      \left[\substFun_{ABC}(\constFun_{AB}(b),\constFun_{A(B{\to}C)}(G))\right]
    \end{array}$\\
    \hline
    \rule{0pt}{3em}
    $\begin{aligned}
      F : A &\to     B\\
          a &\mapsto G(a)
    \end{aligned}$ &
    for $G : A \to B$ &
    $\begin{array}{@{}l@{}}
      G\\
      \compFun_{AAB}(\idFun_A,G)\\
      \dupFun_{AB}(\constFun_{A(A{\to}B)}(G))\\
      \left[\substFun_{AAB}(\idFun_A,\constFun_{A(A{\to}B)}(G))\right]
    \end{array}$\\
    \hline
    \rule{0pt}{2em}
    $\begin{aligned}
      F : A &\to     C\\
          a &\mapsto G(b_a)
    \end{aligned}$ &
    \parbox{3cm}{for $G : B \to C$ \\ and $b_a : B$} &
    $\begin{array}{@{}l@{}}
      \compFun_{ABC}(H,G)\\
      \substFun_{ABC}(H,\constFun_{B(B{\to}C)}(G))
    \end{array}$
    with
    $\begin{aligned}
      H : A &\to     B\\
          a &\mapsto b_a
    \end{aligned}$\\
    \hline
    \rule{0pt}{2.5em}
    $\begin{aligned}
      F : (B \to C) &\to     C\\
          G         &\mapsto G(b)
    \end{aligned}$ &
    for $b : B$ &
    $\begin{array}{@{}l@{}}
      \revAppFun_{BC}(b)\\
      \swapFun_{(B{\to}C)BC}(\idFun_{B{\to}C},b)\\
      \left[\substFun_{(B{\to}C)BC}(\constFun_{(B{\to}C)B}(b),\idFun_{B{\to}C})\right]
    \end{array}$\\
    \hline
    \rule{0pt}{2em}
    $\begin{aligned}
      F : A &\to     C\\
          a &\mapsto G_a(b)
    \end{aligned}$ &
    \parbox{3cm}{for $b : B$ \\ and $G_a : B \to C$} &
    $\begin{array}{@{}l@{}}
      \swapFun_{ABC}(G,b)\\
      \substFun_{ABC}(\constFun_{AB}(b),G)
    \end{array}$
    with
    $\begin{aligned}
      G : A &\to     (B \to C)\\
          a &\mapsto G_a
    \end{aligned}$\\
    \hline
    \rule{0pt}{2em}
    $\begin{aligned}
      F : A &\to     B\\
          a &\mapsto G_a(a)
    \end{aligned}$ &
    for $G_a : A \to B$ &
    $\begin{array}{@{}l@{}}
      \dupFun_{AB}(G)\\
      \substFun_{AAB}(\idFun_A,G)
    \end{array}$
    with
    $\begin{aligned}
      G : A &\to     (A \to B)\\
          a &\mapsto G_a
    \end{aligned}$
  \end{longtable}

  Equivalences between all alternatives can be obtained directly from the axioms
  $\nm{rightId},\nm{leftId},\ldots$ without invoking the functor universe.
  However, this alone would not be sufficient to ensure that there is an equivalence
  between the corresponding final results of the functoriality algorithm.
\end{remark}

\subsection{Functorial meta-relations}

\section{Singletons}
\label{sec:singletons}

\section{Products}
\label{sec:products}

\section{Equivalences}
\label{sec:equivalences}

\section{Properties and relations}
\label{sec:properties}
\label{sec:relations}

\section{Dependent functors}

\section{Dependent products}

\bibliographystyle{plain}
\bibliography{UniverseAbstractions}

\end{document}
