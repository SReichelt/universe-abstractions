\documentclass[a4paper]{article}

\usepackage[margin=2.5cm]{geometry}
\usepackage[parfill]{parskip}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}

\usepackage{amsmath,amssymb,amsfonts,amsthm}

\title{Universe Abstractions\footnote{Still searching for a better title.}}
\author{Sebastian Reichelt}

\setlength{\skip\footins}{0.5cm}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}[definition]{Theorem}
\newtheorem{proposition}[definition]{Proposition}
\newtheorem{lemma}[definition]{Lemma}
\newtheorem{corollary}[definition]{Corollary}
\newtheorem{conjecture}[definition]{Conjecture}
\theoremstyle{remark}
\newtheorem*{remark}{Remark}
\newtheorem*{remarks}{Remarks}
\newtheorem*{example}{Example}

\newcommand{\defn}{\emph}

\renewcommand{\phi}{\varphi}
\renewcommand{\equiv}{\simeq}
\renewcommand{\emptyset}{\varnothing}

\newcommand{\A}{\mathcal{A}}
\newcommand{\B}{\mathcal{B}}
\newcommand{\C}{\mathcal{C}}
\newcommand{\D}{\mathcal{D}}
\newcommand{\U}{\mathcal{U}}
\newcommand{\V}{\mathcal{V}}
\newcommand{\W}{\mathcal{W}}

\newcommand{\nm}{\mathsf}

\newcommand{\universe}{\nm}
\newcommand{\Unit}{\universe{Unit}}
\newcommand{\Bool}{\universe{Bool}}
\newcommand{\Prop}{\universe{Prop}}
\newcommand{\Set}{\universe{Set}}

\newcommand{\id}{\nm{id}}
\newcommand{\apply}{\nm{apply}}
\newcommand{\congrArg}{\nm{wd}}
\newcommand{\fndef}[1]{\nm{def}_{#1}}

\newcommand{\combinator}{\nm}
\newcommand{\idFun}{\combinator{I}}
\newcommand{\revAppFun}{\combinator{T}}
\newcommand{\constFun}{\combinator{K}}
\newcommand{\compFun}{\combinator{B'}}
\newcommand{\revCompFun}{\combinator{B}}
\newcommand{\swapFun}{\combinator{C}}
\newcommand{\dupFun}{\combinator{W}}
\newcommand{\substFun}{\combinator{S'}}
\newcommand{\revSubstFun}{\combinator{S}}

\newcommand{\eqDef}{\overset{\text{def}}{=}}

\newenvironment{anonFun}{\left[\begin{aligned}[c]}{\end{aligned}\right]}

\newcommand{\Lean}{\texttt}

\begin{document}

\maketitle

\section{Introduction}

In this document, we describe a mathematical framework to automate proofs that follow from structural
properties. Such automation can be implemented in theorem provers, and in fact this document is
largely intended as documentation for the accompanying formalization in Lean 4 \cite{lean4}.
At the same time, the algorithms are simple enough to be carried out by hand, and quite often the
existence of an algorithm can be used to prove a result without actually executing the algorithm, so
our results can be useful for informal mathematics as well.

The framework is built around the realization that categories and functors form a simply-typed lambda
calculus \cite{simply-typed-lambda-calculus} when objects are regarded up to isomorphism, because
functors corresponding to the $\nm{S}$ and $\nm{K}$ combinators exist (theorem
\ref{thm:funop}).\footnote{This is different from the interpretation of simply-typed lambda calculus
as the internal logic of a Cartesian closed category, mainly due to the different interpretation of
equality. In particular, our result applies to \emph{any} category, or more precisely to the
collection of categories.}
So it is possible to prove that a function between categories is functorial just by observing that it
is a term in simply-typed lambda calculus, or, as we state it, its definition is built from functor
applications (proposition \ref{prp:functoriality}). We then generalize this result by including
further categorical structures, which corresponds to enriching the lambda calculus with more types.

A particularly useful consequence arises from certain extensionality conditions that hold for
categories: if for two functors $F,G : \C \to \D$ we have an isomorphism between $F(a)$ and $G(a)$
for a sufficiently `generic' $a$ (which we make precise), then we can algorithmically construct a
natural isomorphism between $F$ and $G$ (theorem \ref{thm:extensionality}).

The main goal is to automate proofs of isomorphism invariance in a similar way, but this is work in
progress.

The framework is influenced by ideas from Homotopy Type Theory \cite{hottbook}, but it is built on
conventional mathematical foundations: in this document, we work in Zermelo-Fraenkel (ZF) set
theory with universes, whereas the Lean formalization is directly based on the Calculus of Inductive
Constructions implemented in Lean, without assuming any additional axioms. When we use
type-theoretic notation and vocabulary, it always refers to a specific definition that we give in
this document.

\section{Universes}
\label{sec:universes}

Although we specifically work in Zermelo-Fraenkel (ZF) set theory with (a finite number of)
Grothendieck universes, we will ignore all issues related to the sizes of collections.
Explicit universe constraints are given in the Lean formalization. Since the logic
implemented in Lean has been proved to be equiconsistent with ZF plus choice and a finite
number of inaccessible cardinals \cite{lean-type-theory}, it is safe to assume that analogous
constraints are sufficient in the latter.

Therefore, we reserve the word `universe' for our own use except where specified otherwise:

\begin{definition}
  We define a \defn{universe} to be a pair $(I, (S_A)_{A \in I})$ of
  \begin{itemize}
    \item an index set $I,$ the members of which we call \defn{types}, and
    \item a family $(S_A)_{A \in I}$ of sets indexed by a type. We call the members of $S_A$ the
    \defn{instances} of $A.$
  \end{itemize}
\end{definition}

Given a universe $\U = (I, (S_A)_{A \in I}),$ we write
\begin{itemize}
  \item ``$A \in \U$'' for ``$A \in I$'' and
  \item ``$a :_\U A$'' or usually just ``$a : A$'' for ``$a \in S_A.$''
\end{itemize}

Despite the use of type-theoretic notation and vocabulary, we would like to stress that we are not
defining a type theory; our definitions are just \emph{informed} by type theory.\footnote{One
could also say that we are directly working with \emph{models} of typed lambda calculi. In any case,
we avoid defining the syntax of lambda calculus.}
The words `universe', `type', and `instance' do not carry any meaning beyond what is defined above.

It is important to distinguish between ``$a : A$'' and ``$a \in A$'' because $A$ may in fact be a
set that is different from $S_A.$\footnote{$A$ is always a set in ZF in theory, but in our case it
may also be a set in practice.} This difference can be regarded as an indirection, similarly to
Tarski-style universes in type theory \cite{tarski}.

Since the definition of a universe does not contain any axioms about types and instances, there
are a lot of examples of such universes. Fix a Grothendieck universe $U.$

\begin{itemize}
  \item For every collection $\C \subseteq U$ of sets in $U,$ $\Set_\C := (\C, (S)_{S \in \C})$ is a
  universe for which ``$:$'' and ``$\in$'' coincide.
  If $\C = U,$ we just write ``$\Set$'' (again, ignoring all size issues).
  \item For every collection $\C$ of algebraic structures of the form $(S, t_S)$ with $S \in U,$
  $(\C, (S)_{(S, t_S) \in \C})$ is a universe.\\
  As an example, let $\C$ be the set of all $U$-small groups. Then each type $A$ is a group, and
  each instance $a : A$ is member of the carrier set of $A$ (i.e.\ informally a member of $A$).\\
  The universe of categories will be of particular importance, where types are categories and instances
  are objects in those categories.\\
  Another example is that $\C$ is a collection of universes. Then each type is itself a universe, and
  its instances are the types in that universe.
  \item The previous example generalizes to structures that are built not on sets but on types in a
  universe $\U = (I, (S_A)_{A \in I}).$ Let $\C$ be a collection of structures of the form $(A,t_A)$ with
  $A \in \U$. Then $(\C, (S_A)_{(A, t_A) \in \C})$ is also a universe.
  \item For a universe $\U = (I, (S_A)_{A \in I}),$ any subset $J \subseteq I$ gives rise to a
  \defn{subuniverse} $(J, (S_A)_{A \in J}).$
  \item For any two universes $\U = (I, (S_A)_{A \in I})$ and $\V = (J, (T_B)_{B \in J}),$ we have a
  \defn{product universe} $\U \times \V := (I{\times}J,\,(S_A{\times}T_B)_{(A,B) \in I{\times}J}),$ as
  well as a \defn{sum universe} $\U \uplus \V := (I \uplus J,\,(R_A)_{A \in I \uplus J})$ with
  $R_A := S_A$ for $A \in I$ and $R_B := T_B$ for $B \in J$ (where $I \times J$ denotes the Cartesian
  product and $I \uplus J$ denotes the disjoint union of $I$ and $J$).
\end{itemize}

Furthermore, we define two specific universes of interest:
\begin{itemize}
  \item $\Bool := \Set_{\{0, 1\}},$ where $0$ and $1$ are to be understood as von Neumann ordinals
  \cite{von-neumann-ordinals}, so that $0$ is an empty type and $1$ is a type with a single
  instance $\emptyset : 1.$\footnote{In the Lean formalization of this theory, we have two different universes
  corresponding to the Lean types \Lean{Bool} and \Lean{Prop}. Both of them map to $\Bool$ in this document.}
  \item $\Unit := \Set_{\{1\}}.$
\end{itemize}

Universes are too generic to prove general statements about all universes, so in the following sections
we will define additional structure that universes may or may not have, and prove statements depending
on such additional structure.

\section{Meta-relations}
\label{sec:meta-relations}

\begin{definition}
  For a set $S$ and a universe $\V = (J, (T_B)_{B \in J}),$ we define a \defn{$\V$-valued meta-relation}
  on $S$ to be a function $(\prec) : S \times S \to J.$
\end{definition}

(We reserve the word ``relation'' for section \ref{sec:relations}, where we replace the set $S$ with a type
in a universe.)

We will write $(\prec)$ in infix form, but note that $(\prec)$ is a function and for $a,b \in S,$ the
expression ``$a \prec b$'' is not a formula but a type in $\V.$
We say that $(\prec)$ is
\begin{itemize}
  \item \defn{reflexive} if for every $a \in S$ we have an instance $\id_a : a \prec a,$
  \item \defn{symmetric} if for every $a,b \in S$ and $f : a \prec b$ we have an instance
  $f^{-1} : b \prec a,$ and
  \item \defn{transitive} if for every $a,b,c \in S,$ $f : a \prec b,$ and $g : b \prec c$ we have an
  instance $g \circ f : a \prec c.$
\end{itemize}

Let us first justify the terminology, then the notation. So first consider a (set-theoretic) relation
$(\sim)$ on $S.$ Then for $\V := \Bool$ and
\[(a \prec b) := \begin{cases}
  \, 1 & \text{if } a \sim b,\\
  \, 0 & \text{otherwise}
\end{cases}\]
for $a,b \in S,$ $(\prec)$ is reflexive/symmetric/transitive whenever $(\sim)$ is.

The notation we use for the three specific instances can be understood category-theoretically:
Let $S$ be the set of objects in a category, and let $[a \to b]$ denote the set of morphisms
from $a \in S$ to $b \in S.$ Then the morphism arrow $(\to)$ is in fact a $\Set$-valued
meta-relation on $S,$ and all notations coincide:
\begin{itemize}
  \item A morphism $f : a \to b$ is indeed an instance of the type $[a \to b] \in \Set.$
  \item For each $a \in S,$ we have $\id_a : a \to a.$
  \item For an isomorphism $f : a \to b,$ we have $f^{-1} : b \to a.$
  \item For morphisms $f : a \to b$ and $g : b \to c,$ we have $g \circ f : a \to c.$
\end{itemize}

So morphisms in a category form a reflexive and transitive $\Set$-valued meta-relation.
Moreover, isomorphisms form a reflexive, symmetric, and transitive $\Set$-valued meta-relation.

Note, however, that in general we do not assume that $(\circ)$ is associative, that $\id_a$ is
an identity with respect to $(\circ),$ or that $f^{-1}$ is an inverse of $f.$ We will add such
assumptions later when needed, but in a more general form that avoids equality. For now, we
arbitrarily define the symbol ``$\circ$'' to be right-associative.

(See also \cite{hottbook}, section 2.1.)

\subsection{Instance equivalences}

\begin{definition}
  From now on, we will assume every universe $\U = (I, (S_A)_{A \in I})$ to be equipped with an
  \defn{instance equivalence}, which we define to be
  \begin{itemize}
    \item a universe $\V,$ along with
    \item for each type $A \in \U,$ a reflexive, symmetric, and transitive $\V$-valued
    meta-relation $(\equiv)_A$ on $S_A.$ (In its infix form, we just write ``$\equiv$''.)
  \end{itemize}
\end{definition}

We say that ``$\U$ has instances equivalences in $\V$.''

The idea behind attaching an instance equivalence to a universe is that different universes
have different `natural' notions of equivalence of the instances of their
types.\footnote{When formalizing this theory in HoTT, it should be possible to assume that
all of these instance equivalences are actually equalities.}
Therefore, we will explicitly define instance equivalences for some, but not all, of the
examples given in section \ref{sec:universes}.

\begin{itemize}
  \item For every collection $\C$ of sets, the universe $\Set_\C$ has instance equivalences
  in $\Bool,$ by converting the set-theoretic equality relation on each set in $\C$ to a
  meta-relation as specified in the previous section.\\
  Note that the equivalences of both $\Bool$ and $\Unit$ are then actually in $\Unit$ (as a
  subuniverse of $\Bool$), as each type in $\Bool$ and $\Unit$ has at most one instance.
  \item Universes of simple algebraic structures (groups, rings, vector spaces, etc.)\ have
  the same instance equivalences as $\Set.$ More specifically, universes of algebraic
  structures inherit their instance equivalences from $\Set$ if their elements do not have
  any internal structure that suggests a different definition of instance equivalence.
  This generalizes to structures built on universes other than $\Set.$
  \item In the universe of categories, we define $a \equiv b$ to be the set of
  isomorphisms from $a$ to $b,$ as described in the previous section. Therefore, the
  universe of categories has instance equivalences in $\Set$ instead of $\Bool.$\\
  (Similarly, higher categories generally have instance equivalences in some universe of
  categories or higher categories. We will not investigate this in detail, but it is likely
  that some concepts in this document correspond closely to higher category theory.)
  \item In section \ref{sec:equivalences} we will give a definition of equivalence of types in
  a universe, and this will also be our definition of instance equivalences of universes of
  universes.
  \item Subuniverses inherit instance equivalences from their superuniverse.
  \item If $\U$ has instance equivalences in $\V,$ and $\U'$ has instance equivalences in
  $\V',$ then the product and sum universes $\U \times \U'$ and $\U \uplus \U'$ have instance
  equivalences in $\V \times \V'$ and $\V \uplus \V',$ respectively.
\end{itemize}

We will make sure that in the universes we deal with, for every sequence of universes
$\U_1, \U_2, \ldots,$ where each $\U_k$ has instance equivalences in $\U_{k+1},$ there is
a $k$ such that $\U_k = \U_{k+1} = \cdots = \Unit.$ However, at this point we do not consider
the interactions between the steps in such a sequence.\footnote{Readers familiar with HoTT may
have noticed that instance equivalences should have the structure of a higher groupoid that is
reflected in this sequence. However, we want to specify our assumptions in a more fine-grained
manner.}

\section{Functors}
\label{sec:functors}

The next piece of structure that we attach to universes -- and the first that lets us derive
some concrete results -- is a generalization of functions to what we call \defn{functors}.
Although functors between categories are indeed one special case of this definition, the
conditions are much weaker.

\begin{definition}
  For universes $\U = (I, (S_A)_{A \in I})$ and $\V = (J, (T_B)_{B \in J}),$ a
  \defn{functor type} from $A \in \U$ to $B \in \V$ is a type $[A \to B]$ in a universe $\W$
  with the following two properties:
  \begin{itemize}
    \item For every instance $F : A \to B$ (which we call a \defn{functor}) we have a
    function $\apply_{ABF} : S_A \to T_B.$ Given $a : A,$ we will abbreviate
    ``$\apply_{ABF}(a)$'' to ``$F(a).$''
    \item Moreover, $\apply_{ABF}$ must respect instance equivalences: For each
    $a,b : A,$ we have a function $\congrArg_{ABFab}$ that maps instances of the type
    $a \equiv b$ to instances of $F(a) \equiv F(b).$\footnote{Although ideally we want
    $\congrArg$ to be a functor as well, recursively, at this point we do not make such an
    assumption.}
    For an equivalence $e : a \equiv b,$ we write ``$F(e)$'' for $\congrArg_{ABFab}(e)$ as
    well, matching the corresponding overloaded notation in category theory.
  \end{itemize}
  
  We say that we \defn{have functors from $\U$ to $\V$ in $\W$} if for every $A \in \U$ and
  $B \in \V$ we have a functor type $[A \to B] \in \W.$
  We say that a universe $\U$ has \defn{internal functors} if we have functors from $\U$ to
  $\U$ in $\U.$

  As is common practice, we define the symbol ``$\to$'' to be right-associative, i.e.\ the
  notation ``$A \to B \to C$'' stands for ``$A \to [B \to C].$'' We call such a functor $F$ a
  \defn{bifunctor}, and we write ``$F(a,b)$'' for ``$F(a)(b).$'' (In section \ref{sec:products},
  we will identify $A \to B \to C$ with $A \times B \to C,$ where $A \times B$ is a product
  type.)
\end{definition}

The definition of functors is so generic that we can, in principle, define functors between
many different types in many different universes. However, universes with internal functors
are much more rarer. Let us analyze a few examples.
\begin{itemize}
  \item The functors of $\Set$ are just functions, which respect equality and are obviously
  in $\Set$.
  \item The universe of categories has internal functors: For categories $\C$ and $\D,$ the
  (categorical) functors from $\C$ to $\D$ form a category $\D^\C,$ and we define the type
  $[\C \to \D]$ to be that category.\\
  We need to verify that functors respect instance equivalences. Recall that for objects
  $a$ and $b$ of either $\C$ or $\D,$ the type $a \equiv b$ is the set of isomorphisms from
  $a$ to $b.$ Indeed, functors map isomorphisms to isomorphisms.
  \item The same is true for the universe of groupoids, as a subuniverse of the universe of
  categories, because the category of functors between two groupoids is a groupoid. (For
  suitable definitions of instance equivalences, it should also generalize to higher
  categories and groupoids.)
  \item The morphisms of some, but not all, algebraic structures are also internal functors
  in our sense: In some cases morphisms of a class of structures are themselves instances
  of that class of structures, when operations on morphisms are defined `pointwise'.

  For example, if $f,g : S \to T$ are two morphisms of commutative semigroups, then we can
  define $f \star g$ to be the function that sends each $a \in S$ to $f(a) \ast g(a).$ This
  is easily verified to be a morphism as well, based on associativity and commutativity
  of $(\ast).$ Moreover $(\star)$ inherits associativity and commutativity from $(\ast),$
  turning the set of morphisms from $S$ to $T$ into a semigroup.

  We may investigate the necessary and sufficient conditions more generally later, but for
  now, the following non-exhaustive list of structures with internal functors will have to
  do:
  \begin{itemize}
    \item commutative semigroups, monoids, and groups
    \item modules over a ring
    \item vector spaces over a field
  \end{itemize}
  % TODO: Do commutative rings without 1 work?
  \item Continuous functions between topological spaces can be regarded as internal
  functors of a universe of topological spaces, by fixing a topology on them.
  \item The universe $\Unit$ only has a single type $1,$ so we must set $[1 \to 1] := 1.$
  The type $1$ has exactly one instance $\emptyset,$ so $\apply$ is completely
  defined by $\apply_{11\emptyset}(\emptyset) := \emptyset,$ and $\congrArg$ is completely
  defined by $\congrArg_{11\emptyset\emptyset\emptyset}(\emptyset) := \emptyset.$
  \item For $\Bool,$ we set
  \begin{align*}
    [0 \to 0] &:= 1,\\
    [0 \to 1] &:= 1,\\
    [1 \to 0] &:= 0,\\
    [1 \to 1] &:= 1,
  \end{align*}
  matching logical implication.\footnote{This can be regarded as a degenerate case of
  the Curry-Howard correspondence.} Since $0$ has no instances and $1$ only has
  $\emptyset,$ we need to define three functions $\apply_{00\emptyset},$
  $\apply_{01\emptyset},$ and $\apply_{11\emptyset}.$ The first two have empty domains,
  and the third is again completely defined by
  $\apply_{11\emptyset}(\emptyset) := \emptyset.$
\end{itemize}

\begin{definition}
  For universes $\U$ and $\V$ with functors in $\W,$ types $A \in \U$ and $B \in \V,$
  and a family $(t_a)_{a : A}$ of instances $t_a : B$ (i.e.\ a function from the set of
  instances of $A$ to the set of instances of $B$) we define the notation
  \begin{align*}
    F : A &\to     B\\
        a &\mapsto t_a
  \end{align*}
  to mean that $F$ is a functor from $A$ to $B,$ and that for each $a : A$ we have an instance
  equivalence
  \[\fndef{F}(a) : F(a) \equiv t_a.\]
  We call $\fndef{F}$ the \defn{definition of $F$}. If $\fndef{F}(a) = \id_B$ for all $a : A,$
  we call the definition \defn{strict}.

  We extend this notation to bifunctors: Given appropriate universes and types and a
  family $(t_{ab})_{a : A, b : B},$ we define
  \begin{align*}
    F : A \to B &\to     C\\
        (a,b)   &\mapsto t_{ab}
  \end{align*}
  to mean that $F$ is a functor from $A$ to $[B \to C],$ and that for each $a : A$ and $b : B$ we
  have an instance equivalence $\fndef{F}(a,b) : F(a,b) \equiv t_{ab}.$

  Likewise for \defn{trifunctors} $F : A \to B \to C \to D,$ and so on.
\end{definition}

Note that not every family of instances gives rise to a functor, even though the notation might
suggest it (intentionally, as we will see). We will now assert the existence of certain functors
axiomatically.

\subsection{Functor operations}
\label{sec:funop}

\begin{definition}
  We say that a universe $\U$ with internal functors has \defn{linear functor
  operations}\footnote{The words ``linear'' and ``affine'' refer to linear and affine logic.
  The theory can be modified to incorporate relevant logic as well.}
  if we have the following three functors and six instance equivalences for all types
  $A,B,C,D \in \U.$
  \vspace{1ex}
  \begin{gather*}
    \begin{aligned}
      \idFun_A : A &\to     A\\
                 a &\mapsto a
    \end{aligned}\\[1em]
    \begin{aligned}
      \revAppFun_{AB} : A \to [A \to B] &\to     B\\
                        (a,F)           &\mapsto F(a)
    \end{aligned}\\[1em]
    \begin{aligned}
      \compFun_{ABC} : [A \to B] \to [B \to C] \to A &\to     C\\
                       (F,G,a)                       &\mapsto G(F(a))
    \end{aligned}
  \end{gather*}

  Before stating the required equivalences, we derive two additional functors from $\revAppFun$
  and $\compFun.$
  To improve readability, we want to use the symbol ``$\circ$'' when $\compFun$ is applied to
  two arguments, and indeed the functor arrow $(\to)$ is a $\U$-valued meta-relation on the
  set of types, which, given linear functor operations, is
  \begin{itemize}
    \item reflexive with $\id_A := \idFun_A$ and
    \item transitive with $G \circ F := \compFun_{ABC}(F,G)$ for $F : A \to B$ and
    $G : B \to C.$
  \end{itemize}

  Now we define
  \begin{align*}
    \swapFun_{ABC} &:= \compFun_{B[[B{\to}C]{\to}C][A{\to}C]}(\revAppFun_{BC}) \circ \compFun_{A[B{\to}C]C}\\
                   &: \begin{aligned}[t]
                        [A \to B \to C] \to B \to A &\to     C\\
                        (F,b,a)                     &\mapsto F(a,b)
                      \end{aligned}
  \end{align*}
  and
  \begin{align*}
    \revCompFun_{ABC} &:= \swapFun(\compFun_{ABC})\\
                      &: \begin{aligned}[t]
                           [B \to C] \to [A \to B] \to A &\to     C\\
                           (G,F,a)                       &\mapsto G(F(a))
                         \end{aligned}
  \end{align*}
  (omitting the subscript of $\swapFun$ when applying it to an argument)
  and assert the existence of the following instance equivalences.
  %
  \begin{align*}
    \nm{rightId}_{AB} &: \compFun_{AAB}(\idFun_A) \equiv \idFun_{A{\to}B}\\
    \nm{leftId}_{AB}  &: \revCompFun_{ABB}(\idFun_B) \equiv \idFun_{A{\to}B}\\
    \nm{swapT}_{AB}   &: \swapFun(\revAppFun_{AB}) \equiv \idFun_{A{\to}B}\\
    \nm{swapB'}_{ABC} &: \swapFun_{[B{\to}C]AC} \circ \compFun_{ABC} \equiv \revCompFun_{AB[[B{\to}C]{\to}C]}(\revAppFun_{BC})\\
    \nm{swapB}_{ABC}  &: \swapFun_{[A{\to}B]AC} \circ \revCompFun_{ABC} \equiv \revCompFun_{A[[A{\to}B]{\to}B][[A{\to}B]{\to}C]}(\revAppFun_{AB}) \circ \revCompFun_{[A{\to}B]BC}\\
    \nm{assoc}_{ABCD} &: \compFun_{[B{\to}C][[C{\to}D]{\to}[B{\to}D]][[C{\to}D]{\to}[A{\to}D]]}(\compFun_{BCD}) \circ \revCompFun_{[C{\to}D][B{\to}D][A{\to}D]} \circ \compFun_{ABD} \equiv\\
                      &\:\ \ \revCompFun_{[B{\to}C][A{\to}C][[C{\to}D]{\to}[A{\to}D]]}(\compFun_{ACD}) \circ \compFun_{ABC}
  \end{align*}
\end{definition}

(For the meaning of these equivalences, see lemma \ref{lem:extensional} and proposition
\ref{prp:extensionality-axioms}.)

\begin{remark}
  When defining $\swapFun$ and $\revCompFun,$ we implicitly assumed that we can derive
  instance equivalences
  \[\fndef{\swapFun}(F,b,a) : \swapFun(F,b,a) \equiv F(a,b) \quad \text{for } F : A \to B \to C,\ b : B,\ a : A\]
  and
  \[\fndef{\revCompFun}(G,F,a) : \revCompFun(G,F,a) \equiv G(F(a)) \quad \text{for } G : B \to C,\ F : A \to B,\ a : A.\]
  In order to obtain these, we first establish one further aspect in which functors behave like
  functions.
\end{remark}

\begin{proposition}
  \label{prp:congrfun}
  Given linear functor operations, two functors $F,G : A \to B,$ an instance equivalence
  $e : F \equiv G,$ and an instance $a : A,$ we can obtain an instance equivalence
  $e(a) : F(a) \equiv G(a).$
\end{proposition}
\vspace{-1ex}
\begin{proof}
  The functor $\revAppFun_{AB}(a)$ must respect instance equivalences, so we have an equivalence
  \[\revAppFun_{AB}(a)(e) : \revAppFun_{AB}(a,F) \equiv \revAppFun_{AB}(a,G).\]
  Applying the definition of $\revAppFun_{AB}$ yields an equivalence of the desired type:
  \begin{align*}
    e(a) &:= \fndef{\revAppFun_{AB}}(a,G) \circ \revAppFun_{AB}(a)(e) \circ (\fndef{\revAppFun_{AB}}(a,F))^{-1}\\
         &: F(a) \equiv G(a).
    \qedhere
  \end{align*}
\end{proof}

Together with the other properties of instance equivalences, this proposition establishes
that when constructing an instance equivalence involving functors, we may freely rewrite
along other equivalences, i.e.\ substitute arbitrary subterms. Still, the result will be an
explicit construction, which may be important if e.g.\ equivalences are
isomorphisms.\footnote{In terms of type theory, we are simply doing proof-relevant mathematics.}

We will usually avoid spelling out the details of such constructions,\footnote{Explicit
constructions of all equivalences can be found in the Lean formalization.} but for
demonstration purposes we will explicitly construct $\fndef{\swapFun}$ now.

Recall that ``$\circ$'' is just a shorthand for $\compFun$ in reverse order. So for a given
$F : A \to B \to C,$ the term
$\swapFun(F) = (\compFun_{B[[B{\to}C]{\to}C][A{\to}C]}(\revAppFun_{BC}) \circ \compFun_{A[B{\to}C]C})(F)$
is exactly the left side of an equivalence given by $\fndef{\compFun}$:
\begin{align*}
  e &:= \fndef{\compFun}(\compFun_{A[B{\to}C]C},\compFun_{B[[B{\to}C]{\to}C][A{\to}C]}(\revAppFun_{BC}),F)\\
    &: \swapFun(F) \equiv \compFun_{A[B{\to}C]C}(F) \circ \revAppFun_{BC}.
\end{align*}
Applying proposition \ref{prp:congrfun} to $e$ and an instance $b : B,$ we obtain
\[e(b) : \swapFun(F,b) \equiv (\compFun_{A[B{\to}C]C}(F) \circ \revAppFun_{BC})(b).\]
The right side is again an application of $\compFun,$ so we have
\begin{align*}
  f &:= \fndef{\compFun}(\revAppFun_{BC},\compFun_{A[B{\to}C]C}(F),b)\\
    &: (\compFun_{A[B{\to}C]C}(F) \circ \revAppFun_{BC})(b) \equiv \revAppFun_{BC}(b) \circ F,
\end{align*}
and, applying transitivity of $(\equiv),$
\begin{align*}
  g &:= f \circ e(b)\\
    &: \swapFun(F,b) \equiv \revAppFun_{BC}(b) \circ F.
\end{align*}
Apply proposition \ref{prp:congrfun} to $g$ and an instance $a : A$ to obtain
\[g(a) : \swapFun(F,b,a) \equiv (\revAppFun_{BC}(b) \circ F)(a).\]
This time we have two relevant definitions
\begin{align*}
  h &:= \fndef{\compFun}(F,\revAppFun_{BC}(b))\\
    &: (\revAppFun_{BC}(b) \circ F)(a) \equiv \revAppFun_{BC}(b,F(a)),\\[1ex]
  i &:= \fndef{\revAppFun}(b,F(a))\\
    &: \revAppFun_{BC}(b,F(a)) \equiv F(a,b).
\end{align*}
Finally, we can apply transitivity twice to arrive at
\begin{align*}
  \fndef{\swapFun}(F,b,a) &:= i \circ h \circ g(a)\\
                          &: \swapFun(F,b,a) \equiv F(a,b).
\end{align*}

\begin{remarks}
  For a bifunctor $F : A \to B \to C,$ the bifunctor $\swapFun(F) : B \to A \to C$ behaves
  (up to instance equivalences) like $F$ with swapped arguments. So, informally speaking,
  a bifunctor is a bifunctor regardless of the order of its arguments.

  This should also help clarify the role of $\compFun$ and $\revCompFun.$ The existence
  of $\compFun$ ensures that we can not only compose two functors $F : A \to B$ and
  $G : B \to C$ to $G \circ F : A \to C,$ but also that composition itself is bifunctorial
  in $F$ and $G.$ $\revCompFun,$ then, is the corresponding bifunctor with reversed
  arguments, and in fact we could assert $\revCompFun$ as an axiom and derive $\compFun$
  from it instead.\footnote{Due to a minor technical detail, $\compFun$ leads to a slightly
  more convenient definition of $\swapFun.$}

  Similarly $\revAppFun$ says that for each $a : A,$ the application of $a$ to an
  $F : A \to B$ is functorial, and also that this application functor is functorial in
  $a.$

  Moreover, all of these functors can in fact be regarded as combinators \cite{combinators}
  in a simply-typed lambda calculus \cite{simply-typed-lambda-calculus}, so we use
  established names for these combinators as much as possible.
\end{remarks}

\vspace{1ex}
\begin{definition}
  We say that a universe $\U$ with internal functors has \defn{affine functor
  operations} if it has linear functor operations and additionally the following functor
  and equivalences for all types $A,B,C \in \U.$
  \begin{align*}
    \constFun_{AB} : B \to A &\to     B\\
                     (b,a)   &\mapsto b
  \end{align*}
  \begin{align*}
    \nm{rightConst}_{ABC} &: \compFun_{ABC} \circ \constFun_{AB} \equiv \revCompFun_{[B{\to}C]C[A{\to}C]}(\constFun_{AC}) \circ \revAppFun_{BC}\\
    \nm{leftConst}_{ABC}  &: \compFun_{C[B{\to}C][A{\to}C]}(\constFun_{BC}) \circ \compFun_{ABC} \equiv \constFun_{[A{\to}B][C{\to}A{\to}C]}(\constFun_{AC})
  \end{align*}
\end{definition}

\begin{definition}
  We say that a universe $\U$ with internal functors has \defn{full functor
  operations} if it has affine functor operations and additionally the following functor
  and equivalences for all types $A,B,C \in \U.$

  First we assert the existence of
  \begin{align*}
    \dupFun_{AB} : [A \to A \to B] \to A &\to     B\\
                   (F,a)                 &\mapsto F(a,a)
  \end{align*}
  and derive
  \begin{align*}
    \substFun_{ABC} &:= \revCompFun_{[A{\to}B{\to}C][A{\to}A{\to}C][A{\to}C]}(\dupFun_{AC}) \circ
                        \revCompFun_{A[B{\to}C][A{\to}C]} \circ
                        \compFun_{ABC}\\
                    &: \begin{aligned}[t]
                         [A \to B] \to [A \to B \to C] \to A &\to     C\\
                         (F,G,a)                             &\mapsto G(a,F(a))
                       \end{aligned}
  \end{align*}
  and
  \begin{align*}
    \revSubstFun_{ABC} &:= \swapFun(\substFun_{ABC})\\
                       &: \begin{aligned}[t]
                            [A \to B \to C] \to [A \to B] \to A &\to     C\\
                            (G,F,a)                             &\mapsto G(a,F(a)).
                          \end{aligned}
  \end{align*}

  Then we assert the existence of the following equivalences.
  \begin{align*}
    \nm{dupC}_{AB}      &: \dupFun_{AB} \circ \swapFun_{AAB} \equiv \dupFun_{AB}\\
    \nm{dupK}_{AB}      &: \dupFun_{AB} \circ \constFun_{A[A{\to}B]} \equiv \idFun_{A{\to}B}\\
    \nm{rightDup}_{ABC} &: \revCompFun_{[B{\to}C][A{\to}A{\to}C][A{\to}C]}(\dupFun_{AC}) \circ \compFun_{[B{\to}C][[A{\to}B]{\to}[A{\to}C]][A{\to}A{\to}C]}(\revCompFun_{ABC})\,\circ\\
                        &\hspace{28em}\compFun_{A[A{\to}B][A{\to}C]} \equiv\\
                        &\:\ \ \compFun_{ABC} \circ \dupFun_{AB}\\
    \nm{leftDup}_{ABC}  &: \compFun_{[A{\to}B{\to}B{\to}C][A{\to}B{\to}C][A{\to}C]}(\revCompFun_{A[B{\to}B{\to}C][B{\to}C]}(\dupFun_{BC})) \circ \substFun_{ABC} \equiv\\
                        &\:\ \ \substFun(\substFun_{ABC},\compFun_{[A{\to}B{\to}B{\to}C][A{\to}B{\to}C][A{\to}C]} \circ \substFun_{AB[B{\to}C]})
  \end{align*}
\end{definition}

\begin{lemma}
  \label{lem:extensional}
  The axioms $\nm{rightId},\nm{leftId},\ldots$ hold trivially (whenever the functors
  referenced in those axioms are defined) in any universe that satisfies the following
  extensionality condition:

  If $A$ and $B$ are types, $F,G : A \to B$ are functors, and for every $a : A$ we have
  an equivalence $e(a) : F(a) \equiv G(a),$ then there is also an equivalence
  $e : F \equiv G.$
\end{lemma}

(Note that proposition \ref{prp:congrfun} says that the converse is always true in
a universe with linear functor operations.)

\begin{proof}[Proof for $\nm{rightId}$]
  Under the extensionality condition, the equivalence
  \[\nm{rightId}_{AB} : \compFun_{AAB}(\idFun_A) \equiv \idFun_{A{\to}B}\]
  exists if for every $F : A \to B$ we have an equivalence
  \[\nm{rightId}_{AB}(F) : F \circ \idFun_A \equiv \idFun_{A{\to}B}(F).\]
  By straightforward operations on equivalences and another application of the
  extensionality condition, this equivalence exists if for every $a : A$ we have an
  equivalence
  \[\nm{rightId}_{AB}(F,a) : F(a) \equiv F(a),\]
  which is given by $\id_{F(a)}.$

  The other axioms are analogous.
\end{proof}

\begin{proof}[Alternative proof]
  The functoriality algorithm presented in the next section does not depend on these
  axioms. Therefore we may state them in the alternative form given in proposition
  \ref{prp:extensionality-axioms}, from which lemma \ref{lem:extensional} follows
  immediately.
\end{proof}

\begin{theorem}
  \label{thm:funop}
  The universes with internal functors that are listed in section \ref{sec:functors} have the
  following functor operations.
  \begin{itemize}
    \item $\Unit,$ $\Bool,$ $\Set,$ and the universes of categories and groupoids have
    full functor operations.
    \item The listed universes of algebraic structures have linear functor operations.
  \end{itemize}
\end{theorem}

\begin{proof}
  We will give explicit proofs for some important cases; the remaining axioms and
  universes are analogous.
  %
  \begin{itemize}
    \item In $\Unit,$ we take each functor to be the single instance $\emptyset : 1.$
    All axioms are trivially satisfied.
    %
    \item For $\Bool,$ we can show that all functors exist by doing a case-by-case
    analysis on the types $A,B,\ldots$ being either $0$ or $1.$ This can be simplified by
    treating ``$\to$'' as implication and observing that all implications hold, or even
    further by applying the Curry-Howard correspondence \cite{curry-howard}.\\
    Since $\Bool$ has instance equivalences in $\Unit,$ those are trivially satisfied.
    %
    \item The functors of $\Set$ are just functions. Since functions are
    extensional,\footnote{The theory can also be formalized in a logic without function
    extensionality by \emph{defining} functors between sets to be extensional functions.
    Alternatively/additionally, it is possible to define a universe of setoids, which
    is similar to $\Set$ except that equality is replaced with an equivalence relation.}
    the axioms $\nm{rightId},\nm{leftId},\ldots$ hold by lemma \ref{lem:extensional}.
    %
    \item To show how to construct the required functors in universes of
    structures, we will take $\constFun_{\C\D}$ for categories $\C$ and $\D$ as a
    simple but not completely trivial example.

    The definition of $\constFun_{\C\D}$ says that for objects $c$ of $\C$ and $d$ of
    $\D,$ $\constFun_{\C\D}(d,c)$ must be isomorphic to $d.$ In many cases, we do not
    actually need this flexibility; we can construct a functor that maps strictly to
    $d.$ That is, we show that the expression defining the functor is indeed functorial
    in all arguments starting from the last.\footnote{In the Lean formalization, the
    axioms are already divided into such individual steps, which is often more useful.}

    So the first step is to show that for a fixed object $d$ of $\D$ we have a functor
    \begin{align*}
      K_d : \C &\to     \D\\
            c  &\mapsto d,
    \end{align*}
    i.e. for objects $c,c'$ of $\C$ and a morphism $f : c \to c'$ we need to
    provide a morphism $K_d(f) : K_d(c) \to K_d(c').$ But $K_d(c)$ and $K_d(c')$
    are both $d,$ so we can define $K_d(f)$ to be the identity morphism on $d.$ (Then
    $K_d$ is just the constant functor, of course.)

    The second step is to show that the expression $K_d$ is functorial in $d,$ and
    this will give the desired functor
    \begin{align*}
      \constFun_{\C\D} : \D &\to     \D^\C\\
                         d  &\mapsto K_d.
    \end{align*}
    For objects $d,d'$ of $\D$ and a morphism $f : d \to d',$ we need to provide a
    natural transformation $\constFun_{\C\D}(f) : K_d \Rightarrow K_{d'}.$
    Thus, for each object $c$ of $\C$ we need to give a morphism
    $g_c : K_d(c) \to K_{d'}(c).$ Since $K_d(c) = d$ and $K_{d'}(c) = d',$ we can
    take $g_c := f.$ ($\constFun_{\C\D}$ is known as the diagonal functor.)
    %
    \item The least straightforward case is the construction of $\dupFun_{\C\D}$ for
    categories $\C$ and $\D.$ Following the same strategy as before, first we fix a
    functor $F : \C \to \D^\C$ and need to construct a functor
    \begin{align*}
      W_F : \C &\to     \D\\
            c  &\mapsto F(c)(c).
    \end{align*}
    So for objects $c,c'$ of $\C$ and a morphism $f : c \to c'$ we need to provide
    a morphism $W_F(f) : F(c)(c) \to F(c')(c').$ Since $F(f)$ is a natural
    transformation, the two choices for this morphism are equal:
    \[W_F(f) := (F(f))_{c'} \circ F(c)(f) = F(c')(f) \circ (F(f))_c.\]
    $W_F$ is indeed a functor: We have
    \[W_F(\id_c) = (\id_{F(c)})_{c} \circ \id_{F(c)(c)} = \id_{F(c)(c)}\]
    and for morphisms $f : c \to c'$ and $g : c' \to c''$ in $\C$
    \begin{align*}
      W_F(g \circ f) &= (F(g \circ f))_{c''} \circ F(c)(g \circ f)\\
                     &= (F(g))_{c''} \circ (F(f))_{c''} \circ F(c)(g) \circ F(c)(f)\\
                     &= (F(g))_{c''} \circ F(c')(g) \circ (F(f))_{c'} \circ F(c)(f) \quad \text{by naturality of $F(f)$}\\
                     &= W_F(g) \circ W_F(f).
    \end{align*}
    Now we need to show that $W_F$ is functorial in $F$ to obtain
    \begin{align*}
      \dupFun_{\C\D} : (\D^\C)^\C &\to     \D^\C\\
                       F          &\mapsto W_F.
    \end{align*}
    Given two functors $F,F' : \C \to \D^C$ and a natural transformation
    $\eta : F \Rightarrow F',$ we need to provide a natural transformation
    $\dupFun_{\C\D}(\eta) : W_F \Rightarrow W_{F'}.$ We set
    $(\dupFun_{\C\D}(\eta))_c := (\eta_c)_c$ for each object $c$ of $\C,$
    and need to verify that this is natural in $c.$ Indeed, for every
    morphism $f : c \to c'$ we have
    \begin{align*}
      (\eta_{c'})_{c'} \circ W_F(f) &= (\eta_{c'} \circ F(f))_{c'} \circ F(c)(f)\\
                                    &= (F'(f) \circ \eta_c)_{c'} \circ F(c)(f) \quad \text{by naturality of $\eta$}\\
                                    &= (F'(f))_{c'} \circ (\eta_c)_{c'} \circ F(c)(f)\\
                                    &= (F'(f))_{c'} \circ F'(c)(f) \circ (\eta_c)_c \quad \text{by naturality of $\eta_c$}\\
                                    &= W_{F'}(f) \circ (\eta_c)_c.
    \end{align*}
    It is easily verified that $\dupFun_{\C\D}$ respects identity and
    composition of natural transformations.
    \item Although lemma \ref{lem:extensional} does not apply to the universe of
    categories, the proof strategy for $\nm{rightId},\ldots$ is the same
    as in the proof of that lemma. The difference is that at each step where we
    would apply the extensionality condition, instead we need to verify that the
    equivalences $e(a)$ are natural in $a.$ \qedhere
  \end{itemize}
\end{proof}

\begin{conjecture}
  Theorem \ref{thm:funop} generalizes at least to $n$-groupoids and possibly
  also to $n$-categories.
\end{conjecture}

\begin{conjecture}
  Topological spaces satisfying some mild conditions (compactly generated Hausdorff?)
  also have full functor operations.
\end{conjecture}

\subsection{Functoriality algorithm}

After having shown that several important universes do in fact have linear or even full
functor operations, we will now describe an algorithm to prove functoriality
automatically, i.e.\ to obtain a functor that matches a given definition.

This algorithm is actually just a slight adaptation of the well-known algorithm to
transform lambda abstractions into terms built from combinators \cite{combinators}. In a
simply-typed lambda calculus, this algorithm always terminates. So as long as one is
not interested in the specific behavior of the functor (beyond how it maps instances),
there is no need to execute the algorithm explicitly -- verifying the preconditions
in the following proposition is sufficient.

\begin{proposition}
  \label{prp:functoriality}
  Let $\U$ be a universe with internal functors and (at least) linear functor
  operations, $A_1,\ldots,A_n$ and $B$ be types in $\U,$ and
  $(t_{a_1 \ldots a_n})_{a_k : A_k}$ be a family of instances $t_{a_1 \ldots a_n} : B$
  that are one of the following:
  \begin{itemize}
    \item a constant independent of all $a_k,$
    \item one of the variables $a_k,$ or
    \item a functor application $G_{a_1 \ldots a_n}(b_{a_1 \ldots a_n})$ such that
    both $G_{a_1 \ldots a_n}$ and $b_{a_1 \ldots a_n}$ recursively follow the same
    rules.\footnote{Formally, the rules generate a family $(T_B)_{B \in \U}$ of
    sets $T_B \subseteq F_B,$ where $F_B$ is the set of functions from
    $S_{A_1} \times \dots \times S_{A_n}$ to $S_B,$ and $S_A$ is the set of
    instances of $A$ for each $A \in \U.$}
  \end{itemize}
  Then we have a functor
  \begin{align*}
    F : A_1 \to \dots \to A_n &\to     B\\
        (a_1,\ldots,a_n)      &\mapsto t_{a_1 \ldots a_n}
  \end{align*}
  if the following additional constraints are satisfied.
  \begin{itemize}
    \item If $\U$ only has linear functor operations (but does not have affine
    functor operations), each variable $a_k$ must occur exactly once in $t_{a_1 \ldots a_n}.$
    \item If $\U$ only has affine functor operations (but does not have full
    functor operations), each variable $a_k$ must occur at most once in $t_{a_1 \ldots a_n}.$
  \end{itemize}
\end{proposition}

\begin{proof}
  First, we reduce definitions of bifunctors to definitions of functors; and analogously
  trifunctors to bifunctors, and so on. This principle closely resembles the proof
  strategy in theorem \ref{thm:funop}. To obtain a bifunctor
  \begin{align*}
    F : A_1 \to A_2 &\to     B\\
        (a_1,a_2)   &\mapsto t_{a_1a_2},
  \end{align*}
  first recursively obtain the functor
  \begin{align*}
    F_{a_1} : A_2 &\to     B\\
              a_2 &\mapsto t_{a_1a_2}
  \end{align*}
  for constant $a_1 : A_1.$
  Then recursively obtain the functor
  \begin{align*}
    F' : A_1 &\to     [A_2 \to B]\\
         a_1 &\mapsto F_{a_1}.
  \end{align*}
  Finally set $F := F',$ apply proposition \ref{prp:congrfun} to $\fndef{F'}$ to obtain
  an equivalence $\fndef{F'}(a_1)(a_2) : F(a_1,a_2) \equiv F_{a_1}(a_2),$ and set
  $\fndef{F}(a_1,a_2) := \fndef{F_{a_1}}(a_2) \circ \fndef{F'}(a_1)(a_2).$

  Due to this reduction, we can limit ourselves to the simple case
  \begin{align*}
    F : A &\to     B\\
        a &\mapsto t_a
  \end{align*}
  and perform a (non-exhaustive and non-unique) case split on $t_a.$

  \begin{tabular}{ll|l}
    Desired result & & $F$\\
    \hline\hline
    \rule{0pt}{2em}
    $\begin{aligned}
      F : A &\to     B\\
          a &\mapsto b
    \end{aligned}$ &
    \parbox{3cm}{for $b : B$ (constant \\ with respect to $a$)} &
    $\constFun_{AB}(b)$\\
    \hline
    \rule{0pt}{2em}
    $\begin{aligned}
      F : A &\to     A\\
          a &\mapsto a
    \end{aligned}$ & &
    $\idFun_A$\\
    \hline
    \rule{0pt}{2em}
    $\begin{aligned}
      F : A &\to     B\\
          a &\mapsto G(a)
    \end{aligned}$ &
    for $G : A \to B$ &
    $G$\\
    \hline
    \rule{0pt}{2em}
    $\begin{aligned}
      F : A &\to     C\\
          a &\mapsto G(b_a)
    \end{aligned}$ &
    \parbox{3cm}{for $b_a : B$ \\ and $G : B \to C$} &
    $\compFun_{ABC}(H,G)$ with
    $\begin{aligned}
      H : A &\to     B\\
          a &\mapsto b_a
    \end{aligned}$\\
    \hline
    \rule{0pt}{2em}
    $\begin{aligned}
      F : [B \to C] &\to     C\\
          G         &\mapsto G(b)
    \end{aligned}$ &
    for $b : B$ &
    $\revAppFun_{BC}(b)$\\
    \hline
    \rule{0pt}{2em}
    $\begin{aligned}
      F : A &\to     C\\
          a &\mapsto G_a(b)
    \end{aligned}$ &
    \parbox{3cm}{for $b : B$ \\ and $G_a : B \to C$} &
    $\swapFun_{ABC}(G,b)$ with
    $\begin{aligned}
      G : A &\to     [B \to C]\\
          a &\mapsto G_a
    \end{aligned}$\\
    \hline
    \rule{0pt}{2em}
    $\begin{aligned}
      F : A &\to     B\\
          a &\mapsto G_a(a)
    \end{aligned}$ &
    for $G_a : A \to B$ &
    $\dupFun_{AB}(G)$ with
    $\begin{aligned}
      G : A &\to     [A \to B]\\
          a &\mapsto G_a
    \end{aligned}$\\
    \hline
    \rule{0pt}{3em}
    $\begin{aligned}
      F : A &\to     C\\
          a &\mapsto G_a(b_a)
    \end{aligned}$ &
    \parbox{3cm}{for $b_a : B$ \\ and $G_a : B \to C$} &
    \parbox{6cm}{
      $\substFun_{ABC}(H,G)$ with \\[1ex]
      $\begin{aligned}
        H : A &\to     B\\
            a &\mapsto b_a
      \end{aligned}$
      and
      $\begin{aligned}
        G : A &\to     [B \to C]\\
            a &\mapsto G_a
      \end{aligned}$
    }
  \end{tabular}

  In all cases except the first two, $t_a$ is a functor application. In fact, the
  last case is the most general possible functor application, and in a universe with
  full functor operations, all other cases of functor applications may be regarded as
  mere optimizations.\\
  Note that a functor application with multiple arguments $F(a_1,\ldots,a_n)$ is
  really an application of the functor $F(a_1,\ldots,a_{n-1})$ to the argument $a_n,$
  and must be treated as such.

  One piece of information missing from the table is that the algorithm must produce
  not only the functor $F$ but also an instance equivalence
  $\fndef{F}(a) : F(a) \equiv t_a$ for each $a : A.$ This equivalence is obtained by
  composing the definition of the combinator with the definitions of the recursively
  obtained functors that are passed to the combinator as arguments (if any).
\end{proof}

\begin{remark}
  The algorithm may produce terms of the form $\swapFun(\compFun,\ldots)$ or
  $\swapFun(\substFun,\ldots).$ By the definitions of $\revCompFun$ and $\revSubstFun,$
  these can be replaced with $\revCompFun(\ldots)$ and $\revSubstFun(\ldots),$
  respectively.
\end{remark}

\begin{example}
  Let us consider the simple case where we want to compose a bifunctor
  $F : A \to B \to C$ with a functor $G : C \to D.$ This can be done in
  two different ways: We can either construct this composition for fixed but
  arbitrary $F$ and $G,$ or we can define it as a functor taking $F$ and $G$ as
  arguments.
  
  For fixed $F$ and $G,$ the functor we want to construct is
  \begin{align*}
    H_{FG} : A \to B &\to     D\\
             (a,b)   &\mapsto G(F(a,b)).
  \end{align*}
  The term $G(F(a,b))$ only consists of functor applications, references to the
  constants $F$ and $G,$ and references to the variables $a$ and $b,$ so we
  know that the functoriality algorithm can produce a functor matching this
  definition. Since each variable occurs in this term exactly once, the
  definition is valid in every universe with linear functor operations. If we
  actually execute the algorithm, we find that it outputs
  \[H_{FG} := \revCompFun_{BCD}(G) \circ F\]
  and
  \begin{align*}
    \fndef{H_{FG}}(a,b) &:= \fndef{\revCompFun_{BCD}}(G,F(a),b) \circ \fndef{\compFun_{A[B{\to}C][B{\to}D]}}(F,\revCompFun_{BCD}(G),a)(b)\\
                        &: H_{FG}(a,b) \equiv G(F(a,b)).
  \end{align*}

  We can now interpret this construction in specific universes, for example:
  \begin{itemize}
    \item In the universe of categories:\\
    If $\A,\B,\C,\D$ are categories and $F : \A \to \C^\B$ and $G : \C \to \D$
    are functors, then we have a functor $H : \A \to \D^\B$ such that
    $H(a)(b)$ is isomorphic to $G(F(a)(b))$ for objects $a$ of $\A$ and $b$ of
    $\B.$
    \item In the universe of vector spaces over a field:\\
    If $V,W,X,Y$ are vector spaces over $K,$ $f$ is a linear map from $V$
    to the space of linear maps from $W$ to $X,$ and $g$ is a linear map
    from $X$ to $Y,$ then we have a linear map $h$ from $V$ to the space of
    linear maps from $W$ to $Y$ such that $h(v)(w) = g(f(v)(w))$ for vectors
    $v$ of $V$ and $w$ of $W.$
  \end{itemize}

  If instead we want to construct a functor that takes $F$ and $G$ as
  arguments, we can either execute the functoriality algorithm directly for
  \begin{align*}
    H : [A \to B \to C] \to [C \to D] \to A \to B &\to     D\\
        (F,G,a,b)                                 &\mapsto G(F(a,b)),
  \end{align*}
  or we can use the previous result and construct
  \begin{align*}
    H : [A \to B \to C] \to [C \to D] &\to     [A \to B \to D]\\
        (F,G)                         &\mapsto H_{FG} = \revCompFun_{BCD}(G) \circ F.
  \end{align*}
  The algorithm (always) produces the same result in both cases, which is
  \[H := \compFun_{[C{\to}D][[B{\to}C]{\to}[B{\to}D]][A{\to}B{\to}D]}(\revCompFun_{BCD}) \circ \compFun_{A[B{\to}C][B{\to}D]}.\]
\end{example}

\begin{remark}
  The utility of the functoriality algorithm can be a bit subtle, especially when dealing
  with concrete universes such as the universe of categories. As a rule of thumb, it can
  be used to prove functoriality of terms where all of the objects that appear in the term
  are already functorial. Or, from a reverse point of view, it eliminates the need to
  compose and otherwise manipulate functors explicitly -- instead, functors may simply be
  written as expressions that specify how to map objects, leaving the rest implicit.

  The algorithm becomes even more useful by incorporating further structure that can be
  described abstractly in terms of universes and functors. Then, similarly to the example
  above, we can algorithmically construct functors that involve such structure, and the
  resulting construction will be valid in many universes. Whenever something is
  ``obviously functorial,'' it probably has a universe-based interpretation so that
  functoriality indeed does not need to be proved.
\end{remark}

\begin{proposition}
  \label{prp:funop-def}
  Applying the functoriality algorithm to the definition of any of the combinators
  $\constFun_{AB},\idFun_A,\compFun_{ABC},\revCompFun_{ABC},\revAppFun_{AB},\swapFun_{ABC},\dupFun_{AB},\substFun_{ABC},\revSubstFun_{ABC}$
  results in exactly that combinator.
\end{proposition}
\vspace{-1ex}
\begin{proof}
  This is a simple exercise in executing the functoriality algorithm.
\end{proof}

\begin{proposition}
  In a universe with linear/affine/full functor operations, the functoriality algorithm
  is surjective in the sense that it outputs all functors that can be built from the
  combinators that are valid in that universe.
\end{proposition}
\vspace{-1ex}
\begin{proof}
  For a functor $F : A_1 \to \dots \to A_n \to B,$ applying the functoriality algorithm to
  \begin{align*}
    F' : A_1 \to \dots \to A_n &\to     B\\
         (a_1,\ldots,a_n)      &\mapsto F(a_1,\ldots,a_n)
  \end{align*}
  produces $F' = F$ by repeated application of the third case in the algorithm. This is
  valid in any universe because each $a_k$ is used exactly once, and of course $F$ can be
  a combinator.
\end{proof}

Although the proof is trivial, the proposition is important because we will often
establish something ``for all families of terms that satisfy the constraints of
proposition \ref{prp:functoriality},'' and in those case a suitably modified claim also
holds ``for all functors that can be built from combinators.''

\subsection{Extensionality/naturality algorithm}

In this section, we will introduce an algorithm to prove equivalences of functors given
suitable equivalences of their values, i.e.\ to prove extensionality (which, in the
universe of categories, corresponds to naturality).
First, we introduce a notation for such equivalences.

\begin{definition}
  \label{def:extensional-equivalence}
  Let $A_1\ldots,A_n,B$ be types in (potentially different) universes with functors such
  that we have a functor type $[A_1 \to \dots \to A_n \to B],$ and
  $(s_{a_1 \ldots a_n})_{a_k : A_k}$ and $(t_{a_1 \ldots a_n})_{a_k : A_k}$ be two families
  of instances $s_{a_1 \ldots a_n},t_{a_1 \ldots a_n} : B.$ Then we define the notation
  \begin{align*}
    (A_1 \to \dots \to A_n &\to   B)\\
    e(a_1,\ldots,a_n)      &\ :\  s_{a_1 \ldots a_n} \equiv t_{a_1 \ldots a_n}
  \end{align*}
  to mean that we have an equivalence $e : F_s \equiv F_t$ between the two functors
  $F_s$ and $F_t$ that are obtained by applying the functoriality algorithm to
  $(s_{a_1 \ldots a_n})_{a_k : A_k}$ and $(t_{a_1 \ldots a_n})_{a_k : A_k},$
  respectively, taking the first possible alternative at each step that is nondeterministic.

  We say that an equivalence $e_{a_1 \ldots a_n} : s_{a_1 \ldots a_n} \equiv t_{a_1 \ldots a_n}$
  is \defn{extensional} in $a_1,\ldots,a_n$ if we can obtain an equivalence $e$ as defined above.
\end{definition}

\begin{remark}
  In particular, if $F$ is the functor obtained for $(t_{a_1 \ldots a_n})_{a_k : A_k},$ we
  have
  \begin{align*}
        (A_1 \to \dots \to A_n &\to   B)\\
    \id_F(a_1,\ldots,a_n)      &\ :\  F(a_1,\ldots,a_n) \equiv t_{a_1 \ldots a_n},
  \end{align*}
  i.e.\ the definition $\fndef{F}$ produced by the functoriality algorithm is extensional.
\end{remark}

\begin{proposition}
  \label{prp:extensionality-axioms}
  Using this notation, we can understand the axioms introduced in section \ref{sec:funop}
  as asserting the extensionality of certain equivalences that hold by definition.

  For linear functor operations:
  \begin{gather*}
    \begin{aligned}
                      ([A \to B] \to A &\to   B)\\
      \nm{rightId}_{AB}(F,a)           &\ :\  F(\idFun_A(a)) \equiv F(a)
    \end{aligned}\\[1ex]
    \begin{aligned}
                      ([A \to B] &\to   [A \to B])\\
      \nm{rightId}_{AB}(F)       &\ :\  F \circ \idFun_A \equiv F
      \quad\text{(derived)}
    \end{aligned}\\[1ex]
    \begin{aligned}
                     ([A \to B] \to A &\to   B)\\
      \nm{leftId}_{AB}(F,a)           &\ :\  \idFun_B(F(a)) \equiv F(a)
    \end{aligned}\\[1ex]
    \begin{aligned}
                     ([A \to B] &\to   [A \to B])\\
      \nm{leftId}_{AB}(F)       &\ :\  \idFun_B \circ F \equiv F
      \quad\text{(derived)}
    \end{aligned}\\[1ex]
    \begin{aligned}
                    ([A \to B] \to A &\to   B)\\
      \nm{swapT}_{AB}(F,a)           &\ :\  \revAppFun_{AB}(a,F) \equiv F(a)
    \end{aligned}\\[1ex]
    \begin{aligned}
                      ([A \to B] \to A \to [B \to C] &\to   C)\\
      \nm{swapB'}_{ABC}(F,a,G)                       &\ :\  (G \circ F)(a) \equiv G(F(a))
    \end{aligned}\\[1ex]
    \begin{aligned}
                     ([B \to C] \to A \to [A \to B] &\to   C)\\
      \nm{swapB}_{ABC}(G,a,F)                       &\ :\  (G \circ F)(a) \equiv G(F(a))
    \end{aligned}\\[1ex]
    \begin{aligned}
                      ([A \to B] \to [B \to C] \to [C \to D] \to A &\to   D)\\
      \nm{assoc}_{ABCD}(F,G,H,a)                                   &\ :\  (H \circ G)(F(a)) \equiv H(G(F(a)))
    \end{aligned}\\[1ex]
    \begin{aligned}
                      ([A \to B] \to [B \to C] \to [C \to D] &\to   [A \to D])\\
      \nm{assoc}_{ABCD}(F,G,H)                               &\ :\  (H \circ G) \circ F \equiv H \circ (G \circ F)
      \quad\text{(derived)}
    \end{aligned}
  \end{gather*}
  For affine functor operations:
  \begin{gather*}
    \begin{aligned}
                          (B \to [B \to C] \to A &\to   C)\\
      \nm{rightConst}_{ABC}(b,G,a)               &\ :\  G(\constFun_{AB}(b,a)) \equiv G(b)
    \end{aligned}\\[1ex]
    \begin{aligned}
                          (B \to [B \to C] &\to   [A \to C])\\
      \nm{rightConst}_{ABC}(b,G)           &\ :\  G \circ \constFun_{AB}(b) \equiv \constFun_{AC}(G(b))
      \quad\text{(derived)}
    \end{aligned}\\[1ex]
    \begin{aligned}
                         ([A \to B] \to C \to A &\to   C)\\
      \nm{leftConst}_{ABC}(F,c,a)               &\ :\  \constFun_{BC}(c,F(a)) \equiv c
    \end{aligned}\\[1ex]
    \begin{aligned}
                         ([A \to B] \to C &\to   [A \to C])\\
      \nm{leftConst}_{ABC}(F,c)           &\ :\  \constFun_{BC}(c) \circ F \equiv \constFun_{AC}(c)
      \quad\text{(derived)}
    \end{aligned}
  \end{gather*}
  For full functor operations:
  \begin{gather*}
    \begin{aligned}
                   ([A \to A \to B] \to A &\to   B)\\
      \nm{dupC}_{AB}(F,a)                 &\ :\  \swapFun(F,a,a) \equiv F(a,a)
    \end{aligned}\\[1ex]
    \begin{aligned}
                   ([A \to B] \to A &\to   B)\\
      \nm{dupK}_{AB}(F,a)           &\ :\  \constFun_{A[A{\to}B]}(F,a,a) \equiv F(a)
    \end{aligned}\\[1ex]
    \begin{aligned}
                        ([A \to A \to B] \to [B \to C] \to A &\to   C)\\
      \nm{rightDup}_{ABC}(F,G,a)                             &\ :\  G(\dupFun_{AB}(F,a)) \equiv G(F(a,a))
    \end{aligned}\\[1ex]
    \begin{aligned}
                       ([A \to B] \to [A \to B \to B \to C] \to A &\to   C)\\
      \nm{leftDup}_{ABC}(F,G,a)                                   &\ :\  \dupFun_{BC}(G(a),F(a)) \equiv G(a,F(a),F(a))
    \end{aligned}
  \end{gather*}
\end{proposition}

In the rest of this section, we will show that these axioms imply the extensionality of
\emph{all} such equivalences.

\begin{proposition}
  The following equivalences can be derived from the extensionality axioms.

  \begin{enumerate}
    \item $\nm{swapSwap}(F) : \swapFun(\swapFun(F)) \equiv F$\\for $F : A \to B \to C$
    \item $\nm{dupLeftC}(F,G) : \dupFun_{AC}(\swapFun(G) \circ F) \equiv \substFun_{ABC}(F,G)$\\
    for $F : A \to B$ and $G : A \to B \to C$
    \item $\nm{dupW}(F) : \dupFun_{A[A{\to}B]}(\dupFun_{AB} \circ F) \equiv \dupFun_{AB}(\dupFun_{A[A{\to}B]}(F))$\\
    for $F : A \to A \to A \to B$
    \item $\nm{assocS}(F,G,H) : \substFun_{ABD}(F,\substFun_{A[B{\to}C][B{\to}D]}(G,\revCompFun_{BCD} \circ H)) \equiv
                                \substFun_{ACD}(\substFun_{ABC}(F,G),H)$\\
    for $F : A \to B,$ $G : A \to B \to C,$ and $H : A \to C \to D$
  \end{enumerate}
\end{proposition}

\begin{proof}
  We will only list the axioms that play a central role in the proof.
  \begin{enumerate}
    \item By $\nm{swapT}.$
    \item By $\nm{dupC}$ and $\nm{swapSwap}.$
    \item By $\nm{leftDup}.$
    \item By $\nm{assoc}$ and $\nm{dupW}.$
  \end{enumerate}
  Full proofs (and a lot of further equivalences) are contained in the Lean formalization.
\end{proof}

\vspace{1ex}
\begin{lemma}
  A family $(e_{a_1,a_2})_{a_k : A_k}$ of equivalences is extensional in $(a_1,a_2)$ if
  it is extensional in $a_2$ for fixed $a_1$ and the resulting family of equivalences
  is extensional in $a_2.$
\end{lemma}
\vspace{-1ex}
\begin{proof}
  This follows directly from the construction of the functoriality algorithm.
\end{proof}

Therefore, in the following lemmas, we will restrict ourselves to a single parameter
$a : A.$

\vspace{1ex}
\begin{lemma}
  \label{lem:functoriality-step-equiv}
  When a single step in the functoriality algorithm is nondeterministic, the resulting
  functors are equivalent.
\end{lemma}
\vspace{-1ex}
\begin{proof}
  The following alternatives exist.
  (Brackets indicate that an alternative is redundant because it can also be regarded as an
  alternative of one or more other alternatives.)

  \begin{tabular}{ll|l}
    Case & & Alternatives\\
    \hline\hline
    \rule{0pt}{3em}
    $\begin{aligned}
      F : A &\to     C\\
          a &\mapsto G(b)
    \end{aligned}$ &
    \parbox{3cm}{for $b : B$ \\ and $G : B \to C$} &
    $\begin{array}{@{}l@{}}
      \constFun_{AC}(G(b))\\
      \compFun_{ABC}(\constFun_{AB}(b),G)\\
      \swapFun_{ABC}(\constFun_{A[B{\to}C]}(G),b)\\
      \left[\substFun_{ABC}(\constFun_{AB}(b),\constFun_{A[B{\to}C]}(G))\right]
    \end{array}$\\
    \hline
    \rule{0pt}{3em}
    $\begin{aligned}
      F : A &\to     B\\
          a &\mapsto G(a)
    \end{aligned}$ &
    for $G : A \to B$ &
    $\begin{array}{@{}l@{}}
      G\\
      \compFun_{AAB}(\idFun_A,G)\\
      \dupFun_{AB}(\constFun_{A[A{\to}B]}(G))\\
      \left[\substFun_{AAB}(\idFun_A,\constFun_{A[A{\to}B]}(G))\right]
    \end{array}$\\
    \hline
    \rule{0pt}{2em}
    $\begin{aligned}
      F : A &\to     C\\
          a &\mapsto G(b_a)
    \end{aligned}$ &
    \parbox{3cm}{for $G : B \to C$ \\ and $b_a : B$} &
    $\begin{array}{@{}l@{}}
      \compFun_{ABC}(H,G)\\
      \substFun_{ABC}(H,\constFun_{B[B{\to}C]}(G))
    \end{array}$
    with
    $\begin{aligned}
      H : A &\to     B\\
          a &\mapsto b_a
    \end{aligned}$\\
    \hline
    \rule{0pt}{2.5em}
    $\begin{aligned}
      F : [B \to C] &\to     C\\
          G         &\mapsto G(b)
    \end{aligned}$ &
    for $b : B$ &
    $\begin{array}{@{}l@{}}
      \revAppFun_{BC}(b)\\
      \swapFun_{[B{\to}C]BC}(\idFun_{B{\to}C},b)\\
      \left[\substFun_{[B{\to}C]BC}(\constFun_{[B{\to}C]B}(b),\idFun_{B{\to}C})\right]
    \end{array}$\\
    \hline
    \rule{0pt}{2em}
    $\begin{aligned}
      F : A &\to     C\\
          a &\mapsto G_a(b)
    \end{aligned}$ &
    \parbox{3cm}{for $b : B$ \\ and $G_a : B \to C$} &
    $\begin{array}{@{}l@{}}
      \swapFun_{ABC}(G,b)\\
      \substFun_{ABC}(\constFun_{AB}(b),G)
    \end{array}$
    with
    $\begin{aligned}
      G : A &\to     [B \to C]\\
          a &\mapsto G_a
    \end{aligned}$\\
    \hline
    \rule{0pt}{2em}
    $\begin{aligned}
      F : A &\to     B\\
          a &\mapsto G_a(a)
    \end{aligned}$ &
    for $G_a : A \to B$ &
    $\begin{array}{@{}l@{}}
      \dupFun_{AB}(G)\\
      \substFun_{AAB}(\idFun_A,G)
    \end{array}$
    with
    $\begin{aligned}
      G : A &\to     [A \to B]\\
          a &\mapsto G_a
    \end{aligned}$
  \end{tabular}

  Equivalences between the alternatives given on the right are easily derived from
  the extensionality axioms.
\end{proof}

\begin{lemma}
  \label{lem:combinator-def-equiv}
  For each combinator $F$ that is defined axiomatically in section \ref{sec:funop},
  the applied definition
  \[\fndef{F}(t_a,t'_a,\ldots)\]
  is extensional in $a : A$ if the families $(t_a)_{a : A},(t'_a)_{a : A},\ldots$
  satisfy the conditions of proposition \ref{prp:functoriality}. Specifically, we
  have the following equivalences for suitable families $(b_a),(c_a),(G_a),(H_a)$.
  \begin{enumerate}
    \item \ $\begin{aligned}[t]
                (A   &\to   B)\\
      \nm{extI}_{AB}(a) &\ :\  \idFun_B(b_a) \equiv b_a
    \end{aligned}$
    \item \ $\begin{aligned}[t]
                   (A   &\to   C)\\
      \nm{extT}_{ABC}(a) &\ :\  \revAppFun_{BC}(b_a,G_a) \equiv G_a(b_a)
    \end{aligned}$
    \item \ $\begin{aligned}[t]
                     (A   &\to   D)\\
      \nm{extB'}_{ABCD}(a) &\ :\  \compFun_{BCD}(G_a,H_a,b_a) \equiv H_a(G_a(b_a))
    \end{aligned}$
    \item \ $\begin{aligned}[t]
                   (A   &\to   C)\\
      \nm{extK}_{ABC}(a) &\ :\  \constFun_{BC}(c_a,b_a) \equiv c_a
    \end{aligned}$
    \item \ $\begin{aligned}[t]
                   (A   &\to   C)\\
      \nm{extW}_{ABC}(a) &\ :\  \dupFun_{BC}(G_a,b_a) \equiv G_a(b_a,b_a)
    \end{aligned}$
  \end{enumerate}
\end{lemma}

\begin{proof}
  According to definition \ref{def:extensional-equivalence}, for each of the
  five combinators we need to execute the functoriality algorithm on both sides of
  the equivalence given above, taking the first alternative if the algorithm is
  nondeterministic, and construct an equivalence between the resulting functors.
  Thus, the required constructions are different depending on whether each argument
  is constant, exactly $a,$ or dependent on $a.$

  Fortunately, the previous lemma allows us to combine many of these
  cases,\footnote{A practical implementation of the algorithm may still want to
  handle each case individually to produce shorter terms.}
  except that in a universe with only linear or affine functor operations, we need to
  provide an individual construction for each case where exactly one of the
  arguments depends on $a.$

  This leaves us with the following list.
  In each case, for a family $(t_a)_{a : A}$ of terms $t_a : B$, let $F_t : A \to B$
  denote the functor constructed for $(t_a)_{a : A}$ under the assumption that $t_a$
  depends on $a$ but is not exactly $a.$

  \begin{enumerate}
    \item $\nm{extI}_{AB} := \nm{leftId}_{AB}(F_b).$
    \item If $b_a$ is a constant $b : B,$ then both sides of $\nm{extT}_{ABC}$ are
    $\swapFun(F_G,b).$\\
    If $G_a$ is a constant $G : B \to C,$ we construct an equivalence
    $\nm{extT}_{ABC} : \swapFun(\revAppFun_{BC} \circ F_b,G) \equiv G \circ F_b$
    from $\nm{swapT}.$\\
    If both $b_a$ and $G_a$ depend on $a,$ we construct an equivalence
    $\nm{extT}_{ABC} : \substFun(F_G,\revAppFun_{BC} \circ F_b) \equiv \substFun(F_b,F_G)$
    from $\nm{dupLeftC}.$
    \item If $G_a$ and $H_a$ are constants $G : B \to C$ and $H : C \to D,$ the required
    equivalence is $\nm{extB'}_{ABCD} := \nm{assoc}_{ABCD}(F_b,G,H).$\\
    If $G_a$ and $b_a$ are constants $G : B \to C$ and $b : B,$ we construct an equivalence
    $\nm{extB'}_{ABCD} : \swapFun(\compFun_{BCD}(G) \circ F_H,b) \equiv \swapFun(F_H,G(b))$
    from $\nm{swapB'}.$\\
    If $H_a$ and $b_a$ are constants $H : C \to D$ and $b : B,$ we construct an equivalence
    $\nm{extB'}_{ABCD} : \swapFun(\revCompFun_{BCD}(H) \circ F_G,b) \equiv H \circ \swapFun(F_G,b)$
    from $\nm{swapB}.$\\
    If more than one term depends on $a,$ the required equivalence is
    $\nm{extB'}_{ABCD} := \nm{assocS}(F_b,F_G,F_H).$
    \item If $c_a$ is a constant $c : C,$ the required equivalence is
    $\nm{extK}_{ABC} := \nm{leftConst}_{ABC}(F_b,c).$\\
    If $b_a$ is a constant $b : B,$ we construct an equivalence
    $\nm{extK}_{ABC} : \swapFun_{ABC}(\constFun_{BC} \circ F_c,b) \equiv F_c$ from
    $\nm{rightConst}.$\\
    If both $b_a$ and $c_a$ depend on $a,$ we construct an equivalence
    $\nm{extK}_{ABC} : \substFun_{ABC}(F_b,\constFun_{BC} \circ F_c) \equiv F_c$ from
    $\nm{rightConst},$ $\nm{leftConst},$ $\nm{dupK},$ and $\nm{dupC}.$
    \item The construction of $\nm{extW}_{ABC}$ is only valid in a universe with full
    functor operations. Therefore we can assume that both $G_a$ and $b_a$ depend on $a$
    and set $\nm{extW}_{ABC} := \nm{leftDup}_{ABC}(F_b,F_G).$
    \qedhere
  \end{enumerate}
\end{proof}

\begin{theorem}
  \label{thm:extensionality}
  All equivalences that can be constructed from the axioms defined in section \ref{sec:funop}
  are extensional in all variables (in the sense of definition \ref{def:extensional-equivalence}).

  Specifically, let $\U$ be a universe, $A_1,\ldots,A_n,B$ be types in $\U,$ and
  $(s_{a_1 \ldots a_n})_{a_k : A_k}$ and $(t_{a_1 \ldots a_n})_{a_k : A_k}$ be families
  of instances $s_{a_1 \ldots a_n},t_{a_1 \ldots a_n} \in B,$ and
  $(e_{a_1 \ldots a_n})_{a_k : A_k}$ be a family of instance equivalences
  $e_{a_1 \ldots a_n} : s_{a_1 \ldots a_n} \equiv t_{a_1 \ldots a_n}$ that are one of the
  following:
  \begin{itemize}
    \item a constant independent of all $a_k$ (implying that $s_{a_1 \ldots a_n}$ and
    $t_{a_1 \ldots a_n}$ are also constant),
    \item $\id_{s_{a_1 \ldots a_n}}$ (implying $s_{a_1 \ldots a_n} = t_{a_1 \ldots a_n}$),
    \item $f_{a_1 \ldots a_n}^{-1}$ for an equivalence $f_{a_1 \ldots a_n}$ that recursively
    follows the same rules,
    \item $g_{a_1 \ldots a_n} \circ f_{a_1 \ldots a_n}$ for equivalences $f_{a_1 \ldots a_n}$
    and $g_{a_1 \ldots a_n}$ that recursively follow the same rules,
    \item $G_{a_1 \ldots a_n}(f_{a_1 \ldots a_n})$ for a functor $G_{a_1 \ldots a_n}$ that
    satisfies the constraint of proposition \ref{prp:functoriality} and an equivalence
    $f_{a_1 \ldots a_n}$ that recursively satisfies the constraints of this theorem,
    \item an application of a functor definition
    $\fndef{G}(x_{a_1 \ldots a_n},x'_{a_1 \ldots a_n},\ldots),$ where $G$ is one of the
    combinators that were defined axiomatically in section \ref{sec:funop}, such that
    $x_{a_1 \ldots a_n},x'_{a_1 \ldots a_n},\ldots$ satisfy the constraint of proposition
    \ref{prp:functoriality}.
  \end{itemize}

  Then we can construct an equivalence $e : F_s \equiv F_t$ between the two functors $F_s$
  and $F_t$ that are obtained by applying the functoriality algorithm to
  $(s_{a_1 \ldots a_n})_{a_k : A_k}$ and $(t_{a_1 \ldots a_n})_{a_k : A_k},$ respectively.
  I.e.\ using the notation introduced in definition \ref{def:extensional-equivalence}, we
  have an equivalence
  \begin{align*}
    (A_1 \to \dots \to A_n &\to   B)\\
    e(a_1,\ldots,a_n)      &\ :\  s_{a_1 \ldots a_n} \equiv t_{a_1 \ldots a_n}.
  \end{align*}
\end{theorem}

\begin{proof}
  As in the proof of proposition \ref{prp:functoriality}, we can restrict ourselves to the
  case that $n = 1,$ i.e.\ we replace $a_1,\ldots,a_n$ with a single $a : A.$
  We recursively construct $e$ based on the different cases.
  \begin{itemize}
    \item If $s_a$ and $t_a$ are constants $s,t : B,$ then $F_s = \constFun_{AB}(s)$ and
    $F_t = \constFun_{AB}(t).$ Therefore, if $e_a$ is also a constant $f,$ we can set
    $e := \constFun_{AB}(f).$
    \item If $e_a = id_{s_a}$ implying $s_a = t_a$ for all $a,$ then $F_s = F_t,$ and we
    can set $e := \id_{A{\to}B}.$
    \item If $e_a = f_a^{-1},$ set $e := f^{-1},$ where $f$ is the equivalence obtained
    recursively for $f_a.$
    \item Likewise for $e_a = g_a \circ f_a.$
    \item If $e_a = G_a(f_a) : G_a(u_a) \equiv G_a(v_a)$ for an appropriate functor
    $G_a : C \to B$ and equivalence $f_a : u_a \equiv v_a$ with $u_a,v_a : C,$ then the
    definitions of $F_s$ and $F_t$ depend on whether $G_a,$ $u_a,$ and $v_a$ are constant,
    exactly $a,$ or dependent on $a.$ If $u_a$ and $v_a$ differ in this respect, first
    obtain equivalent alternatives for $F_s$ and $F_t$ according to lemma
    \ref{lem:functoriality-step-equiv}, so that $F_s$ and $F_t$ are both applications of
    the same combinator $H.$ Then $e$ is obtained by applying $H$ to $f$ in the
    appropriate way, where $f$ is the equivalence obtained recursively for $f_a.$
    \item If $e_a = \fndef{G}(x_a,x'_a,\ldots)$ for a combinator $G,$ set $e$ according
    to lemma \ref{lem:combinator-def-equiv}.
    \qedhere
  \end{itemize}
\end{proof}

\begin{corollary}
  \label{cor:extensionality}
  If $F,G : A_1 \to \dots \to A_n \to B$ are functors and
  $(e_{a_1 \ldots a_n})_{a_k : A_k}$ is a family of instance equivalences
  $e_{a_1 \ldots a_n} : F(a_1,\ldots,a_n) \equiv G(a_1,\ldots,a_n)$ that satisfy the
  constraints of theorem \ref{thm:extensionality}, then we have an equivalence
  $e : F \equiv G.$
\end{corollary}

\begin{corollary}
  Whenever the functoriality algorithm is nondeterministic, there are equivalences
  between the resulting functors.\\
  (This strengthens lemma \ref{lem:functoriality-step-equiv}, as an equivalence in
  each step does not necessarily translate to an equivalence in the final result.)
\end{corollary}

\begin{remarks}
  The triviality or nontriviality of this theorem depends on the amount of structure
  that instance equivalences of $\U$ have. In the universe of categories, it is
  already quite significant: If for two functors $F,G : \C \to \D$ we can derive a
  family $(e_c)_{c \in \C}$ of isomorphisms from the axioms given in the previous
  sections, then $F$ and $G$ are naturally isomorphic.

  As with the functoriality algorithm, the usefulness of the theorem increases with
  additional structure that we define on universes. When such structure is equipped
  with appropriate functors and equivalences, theorem \ref{thm:extensionality}
  applies to that additional structure as well.

  The result can also be interpreted as an extensionality theorem in lambda calculus,
  or more specifically in combinatory logic. A proof that extensionality in $\nm{SKI}$
  combinator calculus follows from five axioms is given in \cite{hindley-seldin},
  theorem 8.14. Our result is similar, the key differences being that we also
  incorporate linear and affine logic, and that our theorem is restricted to
  simply-typed lambda calculus.
\end{remarks}

\subsection{Functor universe}
\label{sec:functor-universe}

The functoriality and extensionality algorithms have a metamathematical character. In
this section, we present a purely mathematical approach that offers alternative proofs of
proposition \ref{prp:functoriality} and theorem \ref{thm:extensionality}.

Specifically, we introduce a \defn{functor universe} with the following two properties.
\begin{itemize}
  \item The existence of internal functors in the functor universe corresponds to the
  existence of the $\revSubstFun$ combinator in the base universe, and implies
  proposition \ref{prp:functoriality}.
  \item Functor operations (including the existence of $\revSubstFun$) in the functor
  universe correspond to extensionality in the base universe, and imply theorem
  \ref{thm:extensionality}.
\end{itemize}

First, a word of warning:
In the concrete universes we covered so far, the relationship between a type and the set of
its instances was always very straightforward (although they are truly equal only in $\Set_\C$).
However, in the functor universe we will need to be more careful about the distinction:
Recall that a type is just a member of an index set, and its instances are actually defined
by a family of sets that are indexed by types.

\begin{definition}
  Let $\U$ and $\V = (I, (S_B)_{B \in I})$ and $\W = (J, (T_C)_{C \in J})$ be universes
  such that we have functors from $\U$ to $\V$ in $\W,$ and let $A \in \U.$
  We define the \defn{functor universe} $\V^A$ to be the pair
  \[\V^A := (I, (T_{A \to B})_{B \in I}).\]
  That is,
  \begin{itemize}
    \item the types (or type indices, to be explicit) of $\V^A$ are the same as those of
    $\V,$ but
    \item the instances in $\V^A$ of a type $B \in \V$ are actually functors from $A$ to $B.$
  \end{itemize}
  We let $\V^A$ inherit instance equivalences from $\W.$
\end{definition}

If types $B,C,\ldots \in \V$ are also types of $\V^A$ and vice versa, then the symbols
``$:$'' and ``$\to$'' become ambiguous. To avoid having to annotate each symbol with a
universe, we adopt the purely notational convention that for each type $B \in \V$ we
define $B^A := B$ except that $B^A$ should be understood as a type in $\V^A.$
(Note that we do \emph{not} extend this convention to instances of types; instead we will
use the same notation for an embedding operation.)

So ``$b : B$'' is always an abbreviation for ``$b :_\V B,$'' whereas ``$F : B^A$'' is an
abbreviation for ``$F :_{\V^A} B,$'' so that $F$ is a functor from $A$ to $B,$ not an
instance of $B.$

\subsubsection*{Full functor operations}

We will first concentrate on the case where we have a single universe $\U$ with internal
functors and full functor operations, and a type $A \in \U.$

\begin{proposition}
  \label{prp:fun-univ-full}
  In this case, $\U^A$ also has internal functors, defined by $[B^A \to C^A] := [B \to C]^A$
  for $B,C \in \U.$
\end{proposition}
\vspace{-1ex}
\begin{proof}
  For a functor $G : B^A \to C^A,$ which is also an instance of the type $[A \to B \to C],$
  and an instance $F : B^A,$ which is also an instance of $[A \to B],$ we define their functor
  application in $\U^A$ by $G(F) := \revSubstFun_{ABC}(G,F).$ This definition
  respects instance equivalences because it is an application of the functor
  $\revSubstFun_{ABC}(G).$
\end{proof}

\begin{proposition}
  \label{prp:fun-univ-embed-map}
  $\U$ embeds into $\U^A$: For each type $B \in \U$ and instance $b : B,$ we have
  a corresponding instance $b^A := \constFun_{AB}(b) : B^A.$ This embedding
  respects instance equivalences and functor application, up to instance equivalence.
\end{proposition}
\vspace{-1ex}
\begin{proof}
  As a functor, $\constFun_{AB}$ respects instance equivalences.
  Moreover, for $G : B \to C$ and $b : B$ with $B,C \in \U$ we have an equivalence
  \[\nm{embedMap}(G,b) : G^A(b^A) \eqDef \revSubstFun_{ABC}(\constFun_{A[B{\to}C]}(G),\constFun_{AB}(b)) \equiv
    \constFun_{AC}(G(b)) \eqDef (G(b))^A\]
  by lemma \ref{lem:functoriality-step-equiv}.
\end{proof}

\begin{proposition}
  \label{prp:fun-univ-full-funop}
  $\U^A$ has full functor operations, defined by $\idFun_{B^A} := (\idFun_B)^A,$
  $\revAppFun_{(B^A)(C^A)} := (\revAppFun_{BC})^A, \ldots$ for $B,C \in \U.$
\end{proposition}
\vspace{-1ex}
\begin{proof}
  Clearly these instances are functors of the correct type, and by $\nm{embedMap}$
  they map embedded instances of types in $\U$ to the correct values. However, we
  need to verify that they also map all other instances of $\U^A$ to the values
  specified by their definition, up to equivalence. E.g.\ for $\idFun_{B^A}$ we
  need to provide an equivalence
  \[\fndef{\idFun_{B^A}}(F) : \idFun_{B^A}(F) \eqDef \revSubstFun_{ABC}(\constFun_{AB}(\idFun_B),F) \equiv F\]
  for $F : B^A,$ and likewise for the other four combinators.

  These equivalences can be obtained either via the algorithm given in theorem
  \ref{thm:extensionality}, or directly from the lemmas leading up to that theorem.

  Instance equivalences $\nm{rightId}, \nm{leftId}, \ldots$ in $\U^A$ are trivially
  obtained from the corresponding equivalences in $\U$ by repeated application of
  $\nm{embedMap}.$
\end{proof}

\begin{proposition}
  \label{prp:fun-univ-lift-fun}
  If $G : B \to C$ ($B,C \in \U$) is a functor with definition
  \begin{align*}
    G : B &\to     C\\
        b &\mapsto t_b
  \end{align*}
  where $t_b$ follows the constraints in proposition \ref{prp:functoriality},
  then we can lift the family $(t_b)_{b : B}$ to a family $(T_F)_{F : B^A}$ of
  instances of $C^A,$ which gives a definition
  \begin{align*}
    G^A : B^A &\to     C^A\\
          F   &\mapsto T_F
  \end{align*}
  for the embedded functor $G^A.$
\end{proposition}

\begin{proof}
  We recursively define $T_F$ based on the three possibilities for $t_b.$
  \begin{itemize}
    \item If $t_b$ is a constant $c$ independent of $b,$ we set $T_F := c^A.$
    \item If $t_b = b,$ we set $T_F := F.$
    \item If $t_b$ is a functor application, we set $T_F$ to the application of
    the lifted functor to the lifted term.
  \end{itemize}
  Then, executing the functoriality algorithm for $(t_b)_{b : B}$ and
  $(T_F)_{F : B^A}$ gives results $G' : B \to C$ and $G'' : B^A \to C^A$ that
  only consist of functor applications of constant terms, such that each term
  $x$ in $G'$ corresponds exactly to $x^A$ in $G''.$ Thus by repeated application
  of $\nm{embedMap}$ we obtain an equivalence between $G'^A$ and $G''.$ Composing
  this equivalence with the definitions of $G,$ $G',$ and $G''$ yields the
  required equivalence $\fndef{G^A}(F) : G^A(F) \equiv T_F$ for $F : B^A.$
\end{proof}

We can use this proposition to obtain an alternative proof of proposition
\ref{prp:functoriality} as follows. Given a family $(t_a)_{a : A}$ of terms
$t_a : B$ that satisfy the constraints of proposition \ref{prp:functoriality},
instead of executing the functoriality algorithm we may lift $(t_a)$ to a
family $(T_G)_{G : A^A}$ of terms $T_G : B^A,$ and set the result to
$T_{\idFun_A}.$

This functor is equivalent to the functor $F$ constructed in the proof of
proposition \ref{prp:functoriality} because according to proposition
\ref{prp:fun-univ-lift-fun}, $F^A(G)$ is equivalent to $T_G$ for each $G : A^A,$
and due to the following
\begin{proposition}
  For every $B \in \U$ and $F : A \to B$ we have an equivalence
  \[\nm{embedId}(F) : F^A(\idFun_A) \equiv F.\]
\end{proposition}
\vspace{-2ex}
\begin{proof}
  By $\nm{rightId}.$
\end{proof}

\begin{remark}
  This shows that the functor universe $\U^A$ can be regarded as $\U$ with an
  adjoined element $\idFun_A : A^A,$ which behaves similarly to the symbol $X$
  in a polynomial ring $R[X].$
\end{remark}

\begin{proposition}
  \label{prp:fun-univ-lift-equiv}
  Let $B,C \in \U,$ $(s_b)_{b : B}$ and $(t_b)_{b : B}$ be families of instances
  $s_b,t_b : C,$ and $(e_b)_{b : B}$ be a family of instance equivalences
  $e_b : s_b \equiv t_b$ that satisfy the constraints of theorem
  \ref{thm:extensionality}.

  Then $(e_b)_{b : B}$ lifts to a family $(E_F)_{F : B^A}$ of equivalences
  $E_F : S_F \equiv T_F,$ where $(S_F)$ and $(T_F)$ are lifted from $(s_b)$
  and $(t_b)$ according to proposition \ref{prp:fun-univ-lift-fun}.
\end{proposition}

\begin{proof}
  We recursively define $E_F$ based on the six possibilities for $e_b.$
  \begin{itemize}
    \item If $e_b$ is a constant $e : c \equiv c',$ set
    $E_F := \constFun_{AC}(e) : c^A \equiv c'^A.$
    \item If $e_b = \id_{t_b},$ set $E_F := \id_{T_F}.$
    \item If $e_b$ is $f_b^{-1}$ obtain $E_F$ by recursion.
    \item Likewise for $e_b = g_b \circ f_b.$
    \item If $e_b = G_b(f_b),$ set $E_F := I_F(H_F),$ where $H_F$ is obtained recursively
    from $f_b,$ and $I_F$ is lifted from $G_b.$
    \item If $e_b = \fndef{G}(x_b,x'_b,\ldots)$ for a combinator $G,$ set
    $E_F := \fndef{G^A}(X_F,X'_F,\ldots),$ where $X_F$ is lifted from $x_b,$ etc.
    \qedhere
  \end{itemize}
\end{proof}

This gives rise to an alternative proof of theorem \ref{thm:extensionality} as follows.
Given a family $(e_a)_{a : A}$ of equivalences $e_a : s_a \equiv t_a$ as in theorem
\ref{thm:extensionality}, lift $(e_a)$ to a family $(E_H)_{H : A^A}$ of equivalences
$E_H : S_H \equiv T_H$ in the functor universe $\U^A.$ Since $S_{\idFun_A}$ and
$T_{\idFun_A}$ are equivalent to the functors that the functoriality algorithm
produces for $(s_a)$ and $(t_a),$ respectively, the result can be obtained from
$E_{\idFun_A}.$

\subsubsection*{Linear and affine functor operations}

Now let $\U$ be any universe with at least linear functor operations. If $\U$ does
not have full functor operations, then $\U^A$ does not have internal functors, but
we can either apply a constant functor (i.e.\ in $\U$) to a variable argument
(i.e.\ in $\U^A$) or vice versa.

\begin{proposition}
  \label{prp:fun-univ-linear}
  We have functors from $\U^A$ to $\U^A$ in $\U,$ defined by $[B^A \to C^A] := [B \to C]$
  for $B,C \in \U.$ Moreover, we have functors from $\U$ to $\U^A$ in $\U^A,$
  defined by $[B \to C^A] := [B \to C]^A.$
\end{proposition}
\vspace{-1ex}
\begin{proof}
  For a functor $G : B^A \to C^A,$ which by definition is just an instance of
  $[B \to C],$ and an instance $F : B^A,$ we define their functor application by
  $G(F) := G \circ F.$ For a functor $G : B \to C^A,$ which is an instance of
  $[A \to B \to C],$ and an instance $b : B,$ we define
  $G(b) := \swapFun_{ABC}(G,b).$
\end{proof}

We can unify these functors within a sum universe that additionally includes an
empty type.

\begin{definition}
  For a universes $\U,\V,\W$ such that we have functors from $\U$ to $\V$ in $\W,$
  and a type $A : \U,$ we define the \defn{optional functor universe} $\V^{A?}$ to
  be
  \[\V^{A?} := \V \uplus \V^A \uplus \Set_{\{0\}}.\]
  That is, each type in $\V^{A?}$ is either
  \begin{itemize}
    \item a type $B \in \V,$
    \item a functor type $B^A \in \V^A,$ or
    \item the empty type $0.$
  \end{itemize}
\end{definition}

\begin{proposition}
  For a universe $\U$ with internal functors and at least linear functor operations,
  $\U^{A?}$ has internal functors as follows. For $B,C \in \U,$ we set
  \begin{itemize}
    \item $[B \to C]$ in $\U^{A?}$ to be the same as $[B \to C]$ in $\U,$
    \item $[B \to C^A] := [B \to C]^A,$
    \item $[B^A \to C^A] := \begin{cases}
      [B \to C]^A & \text{if $\U$ has full functor operations}\\
      [B \to C]   & \text{otherwise,}
    \end{cases}$
    \item $[X \to Y] := 0$ for all $X,Y \in \V^{A?}$ not covered above.
  \end{itemize}
  Functor application is defined as in propositions \ref{prp:fun-univ-full} and
  \ref{prp:fun-univ-linear}.
\end{proposition}

\begin{definition}
  For $B,C \in \U$ and $G : B \to C,$ we define $G^{A?} : B^A \to C^A$ by
  \[G^{A?} := \begin{cases}
    G^A & \text{if $\U$ has full functor operations}\\
    G   & \text{otherwise.}
  \end{cases}\]
\end{definition}

\begin{proposition}
  $\nm{embedMap}$ in $\U^A$ generalizes to
  \[\nm{embedMap}^?(G,b) : G^{A?}(b^A) \equiv (G(b))^A.\]
\end{proposition}

\begin{conjecture}
  \label{conj:fun-univ-linear}
  If $\U$ has linear/affine/full functor operations, then so does $\U^{A?}.$
\end{conjecture}

\begin{proposition}
  For every $B \in \U$ and $F : A \to B$ we have an equivalence
  \[\nm{embedId}^?(F) : F^{A?}(\idFun_A) \equiv F.\]
\end{proposition}

\subsection{Functorial meta-relations}

\section{Singletons}
\label{sec:singletons}

\section{Products}
\label{sec:products}

\section{Equivalences}
\label{sec:equivalences}

\section{Properties and relations}
\label{sec:properties}
\label{sec:relations}

\section{Dependent functors}

\section{Dependent products}

\bibliographystyle{plain}
\bibliography{UniverseAbstractions}

\end{document}
